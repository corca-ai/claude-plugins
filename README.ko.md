# CWF (Corca Workflow Framework)

> **Disclaimer: Single Source Of Truth**  
> 이 문서는 CWF 플러그인의 단일 기준점(SSOT)입니다. 문서와 플러그인 구현이 다르면 문서 기준으로 구현을 고쳐야 하니, 사용 중 불일치를 발견하면 이슈/PR로 제보해주세요. CWF를 사용하는 에이전트도 동일하게 행동해주시면 감사하겠습니다.

[English](README.md)

구조화된 개발 세션을 컨텍스트 수집부터 회고 분석까지 반복 가능한 워크플로우로 전환하는 Claude Code 플러그인입니다. [Corca](https://www.corca.ai/)가 [AI-Native Product Team](AI_NATIVE_PRODUCT_TEAM.ko.md)을 위해 개발했습니다. Codex CLI에서도 대부분의 동작이 호환됩니다.

## 빠른 시작

### 설치 및 셋업

```bash
# 마켓플레이스 추가
claude plugin marketplace add https://github.com/corca-ai/claude-plugins.git

# CWF 설치
claude plugin install cwf@corca-plugins
```

이제 Claude Code에서 `cwf:setup`을 실행해주세요. setup은 다음과 같이 작동합니다.

- 프로젝트 설정 파일(`.cwf-config.yaml`, `.cwf-config.local.yaml`) 부트스트랩
- 외부 도구 감지(Codex/Gemini/Tavily/Exa) 및 선택적 Codex 연동
- 로컬 실행 의존성(`shellcheck`, `jq`, `gh`, `node`, `python3`, `lychee`, `markdownlint-cli2`) 점검 및 설치 선택
- 에이전트가 CWF 사용법 및 저장소 탐색을 돕는 인덱스 문서 생성(별도 파일로, 또는 AGENTS.md에 통합)

플래그별 세부 동작은 [setup](#setup) 섹션을 참고하세요.

### Codex 사용자용 셋업

`cwf:setup`만 실행해도 Codex를 위한 안내를 받을 수 있습니다. Codex 연동은 기본적으로 활성 플러그인 스코프(`local > project > user`)를 따릅니다. 아래 명령은 Codex 연동만 별도로 다시 적용하고 싶을 때 사용하시면 됩니다. 자세한 내용은 [Codex 연동](#codex-연동) 섹션을 참고하세요.

```text
cwf:setup --codex
cwf:setup --codex-wrapper
```

### 사용 시나리오

Claude Code / Codex CLI에서 아래처럼 자연어로 시작하면 됩니다.

```text
<문제>를 해결하려고 합니다. cwf:run 워크플로우를 따라 진행해 주세요.
```

그러면 에이전트가 `cwf:run`을 호출해 정보 수집부터 배포 준비까지 전체 과정을 스스로 진행합니다(단, 초기에 사용자와 함께 해소해야만 하는 모호함이 있다면 멈출 수 있습니다). 에이전트가 무슨 일을 했는지 궁금하다면 `cwf:hitl`을 통해 주요 의사결정 포인트와 사용자 쟁점을 문서화한 뒤, 청크 단위로 검토해보세요.

플러그인을 구성하는 13개 스킬은 기본적으로 에이전트를 위한 도구들이며, 최대한 자율적으로 실행되게 되어있으므로 사용자가 자세히 사용법을 이해하는 게 필수는 아닙니다. 하지만 각 스킬의 존재 이유와 구조를 이해하면 CWF를 더 효과적으로 사용하면서 본인만의 워크플로우를 자라나게 하기 쉬워집니다. 자세한 내용이 궁금하신 분들은 하단에서 각 스킬에 대한 설명을 읽어보시길 바랍니다.

### 최신 버전으로 업데이트

```bash
claude plugin marketplace update corca-plugins
claude plugin update cwf@corca-plugins
```

또는 Claude Code / Codex CLI 내에서:

```text
cwf:update               # 새 버전이 있으면 확인 + 자동 업데이트
cwf:update --check       # 버전 확인만
```

### 레거시 플러그인

v3부터 `clarify`, `gather-context`, `retro` 등 독립 플러그인(스킬 및 훅)들은 마켓플레이스에서 제거되어 CWF 안에 통합되었습니다. v3 이전의 플러그인이 설치되어 있다면 제거하고 CWF를 설치하세요.

## 운영 원칙

### CWF의 역할

CWF는 **정보 수집 → 스펙 정제 → 계획 → 구현 → 리뷰 → 리팩토링 → 회고 → 배포 준비**를 하나의 워크플로우로 통합해둔 플러그인입니다. 실제 머지 이후 CI/CD 실행은 각 저장소의 운영 책임 범위에 두고, CWF는 그 직전 단계(GitHub 이슈 및 PR 생성)까지를 자동화·정형화합니다.

CWF는 사용자의 컨텍스트 관리 부담을 최소화하기 위해 세션 상태 기록, 세션 로그 산출물, 훅을 통해 페이즈/세션 경계를 넘어 의사결정 사항과 교훈을 보존합니다. 모든 스킬의 공통 계약은 `컨텍스트 결손 복원력`입니다. 즉, auto-compact나 세션 재시작 이후에도 `.cwf/cwf-state.yaml`, 세션 산출물, 핸드오프 파일만으로 실행을 복구해야 하며, 암묵적 대화 메모리에 의존하면 계약 위반으로 간주합니다.

각 스킬은 **전문가 자문, 티어 분류, 에이전트 조율, 의사결정 포인트, 핸드오프, 출처 추적, 적응형 계약**이라는 7가지 핵심 컨셉을 조립해 재구성한 것입니다. 여기서 '컨셉'이란 [Daniel Jackson의 정의](references/essence-of-software/distillation.md)에 따라, '사용자에게 보이는 기능을 명확하고 이해 가능한 목적으로 묶은 재사용 가능한 단위'를 뜻합니다. 각 컨셉은 자신의 상태를 유지하고 사용자(및 다른 컨셉)와 원자적 액션으로 상호작용하며, CWF는 이를 스킬 간 공용 설계 규약으로 사용합니다.

### CWF의 범위 밖

- CWF는 프로젝트별 엔지니어링 표준, CI 게이트, 사람의 제품 책임 의사결정을 대체하지 않습니다.
- CWF는 모든 결정을 완전히 자동화할 수 있다고 보장하지 않으며, 주관적 결정에는 여전히 사용자 확인이 필요합니다.
- CWF 플러그인 내의 모든 스킬은 의도적으로 강결합되도록 설계되어 있습니다. 개별 스킬을 복사해서 쓰시는 분들은 이 점을 유의하시고, 에이전트에게 독립 사용에 적합하게 수정해달라고 하시길 바랍니다.

### 핵심 가정

- 사용자는 토큰이 이미 충분히 싸고 앞으로 더 싸질 것이라는 전제를 수용합니다. CWF는 코딩 에이전트를 사실상 무제한(예: Claude Code / Codex $200 플랜)으로 사용할 수 있는 사람을 대상으로 설계됐습니다.
- 사용자는 새로운 세션 또는 컨텍스트 압축 이후에도 상태/산출물/핸드오프를 통해 맥락이 충분히 복구될 것을 믿으며, 에이전트에게 긴 작업을 맡깁니다.
- 사용자는 본인의 프롬프트와 에이전트의 작업을 비롯한 세션의 모든 산출물이 저장소 내에 자동으로 기록되고 활용되기를 기대합니다.

## 왜 CWF인가?

### 문제

AI 에이전트는 이미 충분히 똑똑하나, 아직까지는 긴 작업을 안정적으로 수행하려면 적절한 도구와 환경이 갖춰져야 합니다. 그 중 가장 중요한 것이 컨텍스트와 결정 이력의 보존입니다. 세션/페이즈 경계에서 컨텍스트가 끊기면 다음 작업은 다시 탐색부터 시작되고, 사람과 합의한 제약도 쉽게 누락되기 때문입니다.

또 다른 핵심 환경 요소는 에이전트 동작을 지속적으로 교정하는 품질 게이트입니다. 프로젝트 규모가 커질수록 설계 문서, 스킬 동작, 훅/스크립트가 서로 어긋나기 쉬워지고, 저품질 코드와 문서가 중구난방 양산되며, 검증 규칙이 실제 상태를 따라가지 못하는 문제가 반복됩니다.

마지막으로, 긴 작업을 병렬로 더 많이 돌릴수록 병목은 인간의 뇌로 이동합니다. 사람의 판단/검증 속도가 에이전트의 출력량을 따라가지 못한다면, 단순한 병렬화로는 전체 리드타임을 일정 이상 줄이기 어렵습니다.

### 접근

토큰은 이미 싸고 더 싸질 것이므로, CWF는 효율보다는 효과를 기준으로 설계되었습니다. 토큰을 많이 써서 사용자가 할 일을 줄일 수 있다면 그렇게 합니다. 사용자 검토가 필요한 지점에서는 `cwf:hitl`로 합의와 검토를 구조화합니다. 그렇다고 효율을 완전히 등한시한다는 뜻은 아닙니다. 토큰을 많이 쓰다 보면 결국 단위 시간당 토큰의 질이 높아져야 하므로, 회고를 통해 작업 방식과 프롬프트를 지속적으로 개선해 반복 세션에서 효율도 함께 높입니다.

핵심은 다음 다섯 가지입니다.

1. 충분한 맥락을 먼저 수집하고(가설보다 증거 우선)
2. 사용자와 합의한 의사결정/계획을 파일 기반 지속 메모리로 남기며
3. 훅과 결정적 검증으로 에이전트가 올바른 문서와 코드를 작성하도록 강제하고
4. 회고로 프로세스와 도구를 계속 개선하는 자가 치유 루프를 유지하고
5. 필요한 지점에서는 사용자가 쉽게 개입할 수 있게 한다

이를 위해 다음과 같이 의사결정했습니다.

- **독립 플러그인 대신 통합 플러그인**: 페이즈 간 컨텍스트 손실과 단계별 실행 규칙의 일관성 붕괴를 방지하기 위해서입니다.
- **사용자 개입은 앞뒤에, 나머지는 자율로**: 불확실성을 중요한 순간에 줄여주기만 하면 에이전트가 나머지는 지능적으로 실행할 수 있다고 믿기 때문입니다.
- **핸드오프 문서의 경로만 입력해도 다음 단계가 시작되도록 작성**: 세션 연속성을 신뢰할 수 있게 만들고, 다음 작업 시작 시의 모호성을 줄이기 위해서입니다.

### 결과

하나의 플러그인(CWF), 13개 스킬, 9개 훅 그룹. 컨텍스트는 세션 경계를 넘어 유지되고, 의사결정은 증거 기반으로 이루어지며, 품질 기준은 시스템과 함께 진화합니다.

## 핵심 개념: CWF의 빌딩 블록 7개

CWF 스킬이 조합하는 7가지 재사용 가능한 행동 패턴입니다. 아래 순서는 문제를 구조화하고(의사결정 포인트), 관점을 넓혀 검증하고(전문가 자문), 결정 권한을 배분한 뒤(티어 분류), 실행/연속성/기준 관리로 이어지는 운영 흐름을 반영합니다.

**의사결정 포인트** -- 모호한 요구를 검토 가능한 선택지로 변환합니다. 결정을 내리기 전에 질문 단위로 분해해 모든 선택의 근거를 기록합니다.

**전문가 자문** -- 같은 의사결정 포인트를 서로 다른 전문 프레임으로 재검토해 숨은 가정과 리스크를 조기에 드러냅니다. 의사결정 포인트가 "무엇을 결정할지"를 구조화한다면, 전문가 자문은 "그 결정을 어떤 관점으로 검증할지"를 보강합니다.

**티어 분류** -- 의사결정의 성격에 맞는 주체로 권한을 라우팅합니다. 코드베이스 증거 기반(T1)과 표준/모범사례 기반(T2)은 에이전트가 자율 처리하고, 선호·정책처럼 정답이 없는 결정(T3)만 사용자에게 올립니다.

**에이전트 조율** -- 처리량을 늘리면서도 결과 일관성을 유지합니다. 복잡도에 맞춰 최소 팀을 구성하고 의존성 기반 배치로 실행한 뒤 결과를 하나로 종합합니다.

**핸드오프** -- 페이즈/세션 경계에서 다시 시작하는 비용을 없앱니다. 세션 핸드오프는 맥락과 교훈을, 페이즈 핸드오프는 프로토콜과 제약을 전달합니다.

**출처 추적** -- 오래된 기준이 현재 작업을 조용히 오염시키지 않게 합니다. 여기서 기준은 리뷰 체크리스트, 설계 원칙, 운영 규칙 같은 작업 판단 근거를 뜻하며, CWF는 참조 문서의 시스템 상태 메타데이터를 확인한 뒤에만 이를 재사용합니다.

**적응형 setup 계약** -- setup의 이식성을 유지하면서도 현재 저장소 도구 체인에 맞게 초기 설정을 조정합니다. 첫 setup에서 계약 초안을 만들고(core baseline + repo 제안), repo 고유 도구는 명시적 승인 후에만 적용합니다.

## 워크플로우

CWF의 기본 실행 체인은 아래와 같습니다:

```text
gather → clarify → plan → review(plan) → impl → review(code) → refactor → retro → ship
```

| # | 스킬 | 트리거 | 하는 일 |
|---|------|--------|---------|
| 1 | [gather](#gather) | `cwf:gather` | URL/웹/로컬 증거를 수집해 에이전트 친화 산출물로 정리 |
| 2 | [clarify](#clarify) | `cwf:clarify` | 요구사항을 의사결정 포인트로 분해하고 티어 분류로 계획 입력을 정제 |
| 3 | [plan](#plan) | `cwf:plan` | 구현 범위/파일/검증 가능한 성공 기준을 명시한 실행 계약 작성 |
| 4 | [impl](#impl) | `cwf:impl` | 승인된 계획을 작업 단위로 분해해 실행하고 완료 기준으로 검증 |
| 5 | [retro](#retro) | `cwf:retro` | 세션 결과를 분석해 교훈과 도구/프로세스 개선 항목으로 환원 |
| 6 | [refactor](#refactor) | `cwf:refactor` | 코드·스킬·문서·스크립트를 함께 정리해 전역 정합성 회복 |
| 7 | [handoff](#handoff) | `cwf:handoff` | 세션/페이즈 전환용 핸드오프 문서 생성 및 상태 연결 |
| 8 | [ship](#ship) | `cwf:ship` | 이슈/PR/머지 단계를 템플릿과 가드레일로 일관되게 실행 |
| 9 | [review](#review) | `cwf:review` | 요구/계획/코드에 공통 품질 게이트를 적용하는 다각도 리뷰 |
| 10 | [hitl](#hitl) | `cwf:hitl` | 합의 라운드와 청크 검토를 재개 가능한 상태로 운영 |
| 11 | [run](#run) | `cwf:run` | gather부터 ship까지 전체 파이프라인을 단계 게이트로 조율 |
| 12 | [setup](#setup) | `cwf:setup` | 훅/도구/setup·설정/인덱스 계약을 초기 표준값으로 부트스트랩하고 repo별 제안을 분리 제시 |
| 13 | [update](#update) | `cwf:update` | CWF 동작을 최신 계약/수정사항과 동기화 |

## 스킬 레퍼런스

- 플래그별 명령 매트릭스, 예외 실행 플로우, 저수준 롤백 내부 동작은 포함하지 않습니다. 자세한 내용은 각 스킬의 `SKILL.md`와 스킬별 `references/`에서 확인하세요.
- 모든 스킬은 실행시 `.cwf/projects/{session-dir}/` 산출물과 `.cwf/cwf-state.yaml` 상태 정보가 갱신될 수 있습니다.
- 전문가 관점은 코드/웹 근거만으로는 놓치기 쉬운 가정, 트레이드오프, 리스크를 조기에 드러내 의사결정 품질을 보강하기 위해 사용합니다.
- `clarify`, `review`, `retro`(심층)는 세션 간 관점 연속성이 중요하므로, 활용한 전문가를 `cwf-state.yaml`의 `expert_roster`에 기록하고 다음 실행에서 재사용합니다.
- `refactor --codebase --deep`는 목적이 "세션 연속성"보다 "코드베이스 기준 재현성"에 가까워 `expert_roster`를 쓰지 않고, `codebase-contract.yaml`의 고정 전문가+컨텍스트 전문가 구성을 계약 기반으로 선택합니다.

### [gather](plugins/cwf/skills/gather/SKILL.md)

**의의**

추론/구현 전에 흩어진 외부 컨텍스트를 파일 기반 증거로 고정해, 후속 단계가 동일한 사실 기반에서 움직이게 만들고 출처 메타데이터를 함께 남겨 이후 판단 근거를 역추적할 수 있게 합니다.

**Input(입력값)**

- 사용자가 URL을 제공하거나, "코드베이스를 읽고" 처럼 근거 수집을 요청할 때 실행됩니다. (지원 범위: URL 수집, 웹 검색, GitHub/Slack/Notion 문서, 로컬 코드베이스 탐색)
- 사용자가 `cwf:run`으로 작업을 요청하면 파이프라인 첫 단계에서 실행되어, 이후 단계가 사용할 초기 증거 묶음을 만듭니다.

**Process(입력의 처리 방법)**

- URL/웹/로컬 대상을 수집해 `.cwf/projects/`에 재사용 가능한 산출물로 정규화하고, 출처 정보를 함께 기록합니다.  
- 웹 검색은 검색 효과 및 효율을 높이기 위해 외부 API(Tavily/Exa)를 활용합니다. API 키가 없으면 설정 여부를 묻고, URL/로컬 수집처럼 가능한 경로로 계속 진행합니다.

**Output(파일 산출물 및 에이전트 응답)**

- 파일 생성: `.cwf/projects/` 아래에 수집 결과 `.md`/`.meta.yaml` 산출물이 생성됩니다.
- 파일 수정: 같은 대상을 재수집하면 기존 산출물이 최신 내용으로 갱신될 수 있습니다.
- 에이전트 응답: 수집된 근거 범위, 실패/보완 필요 항목, 다음 단계 연결 요약이 함께 제공됩니다.

**샘플 시나리오**

1. 직접 실행:
    - 입력: "이 PR과 <링크> 슬랙 스레드를 <링크> gather 해주세요."
    - 결과: `.cwf/projects/` 아래에 관련 `.md`/`.meta.yaml` 산출물이 생성되고, 수집된 근거 범위를 요약한 응답이 반환됩니다.
2. `cwf:run` 실행:
    - 입력: "결제 실패에 대한 유저 리포트가 왔습니다. <깃헙 이슈 링크> 원인 파악하고 수정까지 진행해주세요. CWF로 해주세요."
    - 결과: 첫 단계에서 조사 산출물이 생성되고, 그 파일들을 근거로 다음 `clarify` 단계가 이어집니다.

### [clarify](plugins/cwf/skills/clarify/SKILL.md)

**의의**

요구사항 모호성을 구현 전에 의사결정 단위로 바꿔 불필요한 재작업을 줄이고, 코드/표준 근거로 자율 해소 가능한 항목을 먼저 정리해 선호·정책처럼 사용자 판단이 필요한 선택만 남기도록 합니다.

**Input(입력값)**

- 사용자가 요구사항 정리/합의 구조화를 요청할 때 실행됩니다.
- 사용자가 `cwf:run`으로 작업을 요청하면 기본 체인에서 `gather` 다음 단계로 실행되어, 구현 전에 합의가 필요한 항목을 분리합니다.

**Process(입력의 처리 방법)**

- 요구사항을 의사결정 포인트로 분해해 T1/T2/T3로 분류합니다.
- T1: 코드베이스 근거로 자율 결정 가능한 항목
- T2: 웹상의 표준/베스트프랙티스 근거로 자율 결정 가능한 항목
- T3: 선호·정책처럼 사용자 판단이 필요한 항목
- T1/T2는 코드베이스/웹/전문가 근거를 모아 자율 결정으로 정리하고, T3만 사용자 질문으로 승격합니다.
- 기본 모드에서는 서로 다른 프레임워크의 전문가 2명을 병렬로 활용해 중요한 결정 리스크를 보강하고, 근거 충돌 시 해당 항목을 T3로 승격해 사용자 판단으로 넘깁니다.

**Output(파일 산출물 및 에이전트 응답)**

- 파일 생성: 세션 디렉토리에 `clarify-*.md` 조사 산출물과 요구사항 요약 파일이 생성됩니다. 라이트 모드(`--light`)에서는 일부 조사 파일이 생략될 수 있습니다.
- 파일 수정: `cwf-state.yaml`의 clarify 완료 정보(`clarify_completed_at`, `clarify_result_file`)가 갱신됩니다.
- 에이전트 응답: 모호한 요청이 의사결정 포인트(T1/T2/T3)로 구조화되고, T3는 사용자 질문으로 분리됩니다.

**샘플 시나리오**

1. 직접 실행:
    - 입력: "이 기능 요청 원문 <노션 링크> 기반으로, 구현 전에 결정해야 할 항목부터 명확하게 정리해주세요."
    - 결과: 의사결정 포인트와 근거가 포함된 정리 응답이 반환되고, 요구사항 요약 파일과 완료 상태가 저장됩니다.
2. `cwf:run` 실행:
    - 입력: "<이슈 링크> 이 이슈의 신규 온보딩 개선 요청을 CWF로 작업해주세요."
    - 결과: `gather` 근거를 받아 `clarify`에서 결정 포인트/미해결 선택을 분리한 뒤, 계획 단계로 넘길 정제된 요구사항이 생성됩니다.

### [plan](plugins/cwf/skills/plan/SKILL.md)

**의의**

구현과 리뷰가 같은 기준으로 움직이도록 실행 가능한 계획 계약을 먼저 고정합니다. 런타임별로 동작이 다른 Plan mode에 의존하는 대신 `plan.md`/`lessons.md`/`phase-handoff` 파일 계약으로 컨텍스트 연속성을 유지합니다.

**Input(입력값)**

- 사용자가 구현 전에 범위/파일/검증 기준이 포함된 실행 계획 작성을 요청할 때 실행됩니다.
- 사용자가 `cwf:run`으로 작업을 요청하면 기본 체인에서 `clarify` 다음 단계로 실행되어, 이후 `review(plan)`과 `impl`의 기준 입력을 만듭니다.

**Process(입력의 처리 방법)**

- `gather`/`clarify`에서 정리된 근거와 의사결정 포인트를 우선 읽어 범위, 변경 대상 파일, 테스트 가능한 성공 기준을 계획 계약으로 구조화합니다.  
- 기존 근거로 해결되지 않는 항목이 남아 있을 때만 코드베이스 분석과 선행 사례 조사를 추가로 수행합니다.  
- 계획 수립 중 사용자와의 핑퐁에서 드러난 제약·선호·가정 수정 사항을 `lessons.md`에 즉시 반영합니다.

**Output(파일 산출물 및 에이전트 응답)**

- 파일 생성: 세션 디렉토리에 `plan.md`, `lessons.md`가 생성됩니다(없으면 bootstrap).
- 파일 수정: 재실행 시 `plan.md`/`lessons.md`가 최신 결정사항으로 갱신되며, 계획 단계에서 새로 확인된 학습도 `lessons.md`에 누적됩니다.
- 에이전트 응답: 구현 전 `cwf:review --mode plan` 적용 여부와 미해결 가정이 함께 안내됩니다.

**샘플 시나리오**

1. 직접 실행:
    - 입력: "요구사항 정리는 끝났어요. 이제 실제 수정 파일이랑 테스트 기준까지 포함한 실행 계획을 만들어주세요."
    - 결과: `plan.md`가 생성되고, 구현 전에 확인해야 할 미해결 항목이 함께 정리됩니다.
2. `cwf:run` 실행:
    - 입력: "이번 결제 리팩터링 작업, CWF로 처음부터 끝까지 진행해주세요."
    - 결과: `clarify` 다음에 `plan`이 실행되어 `review(plan)`과 `impl`이 같은 기준으로 이어집니다.

### [impl](plugins/cwf/skills/impl/SKILL.md)

**의의**

승인된 계획을 제약 누락 없이 실제 코드 변경으로 전환해 예측 가능한 구현 실행을 보장하고, 계획 범위 이탈을 막은 채 완료 판단 근거를 남겨 리뷰/후속 단계가 같은 기준으로 이어지게 합니다.

**Input(입력값)**

- 사용자가 승인된 `plan.md` 기준으로 구현 실행을 요청할 때 실행됩니다.
- 사용자가 `cwf:run`으로 작업을 요청하면 기본 체인에서 `review(plan)` 게이트를 통과한 뒤 실행되어, 계획의 성공 기준을 만족하는 변경을 수행합니다.

**Process(입력의 처리 방법)**

- 선택된 `plan.md`를 의존성 기준 작업 단위로 분해해 순차/병렬 실행 경계를 설정합니다.  
- 브랜치/clarify 선행 게이트를 확인한 뒤 구현을 수행하고, 완료 여부를 성공 기준과 검증 결과로 확인합니다.

**Output(파일 산출물 및 에이전트 응답)**

- 파일 생성: 구현 과정에서 세션 결과 파일(예: 에이전트 실행 결과, 후속 세션 문서)이 생성될 수 있습니다.
- 파일 수정: 계획 대상 코드/설정 파일이 작업 단위 기준으로 수정됩니다.
- 에이전트 응답: 성공 기준(BDD 포함) 충족 여부, 남은 리스크, 후속 조치가 근거와 함께 보고됩니다.

**샘플 시나리오**

1. 직접 실행:
    - 입력: "방금 승인한 plan.md 기준으로 구현 시작해주세요. 테스트까지 완료 여부 보고해주세요."
    - 결과: 계획에 맞는 코드 변경과 검증 결과 요약이 생성됩니다.
2. `cwf:run` 실행:
    - 입력: "회원 가입 플로우 개선 작업을 CWF로 끝까지 진행해주세요."
    - 결과: `review(plan)` 통과 후 `impl`이 실행되어 코드 변경과 검증이 진행됩니다.

### [retro](plugins/cwf/skills/retro/SKILL.md)

**의의**

한 번의 작업 결과를 재사용 가능한 개선 지식으로 바꿔 다음 세션의 시행착오를 줄이고, 회고가 기록으로만 끝나지 않도록 다음 실행 규칙과 문서 개선 입력으로 연결합니다.

**Input(입력값)**

- 사용자가 세션 마무리 시 회고 정리와 다음 개선 항목 도출을 요청할 때 실행됩니다.
- 사용자가 `cwf:run`으로 작업을 요청하면 기본 체인에서 `refactor` 다음 단계로 실행되어, 이번 실행의 교훈을 정리합니다.

**Process(입력의 처리 방법)**

- 세션 산출물과 로그를 수집해 원인·패턴·개선안을 구조화합니다.  
- 모드(기본 심층/`--light`)에 따라 분석 깊이를 조정하고, 결과를 eval/state/doc 적용 레이어로 연결합니다.
- 심층 모드에서는 Expert Lens를 추가해 서로 다른 프레임워크 관점으로 세션 결정을 재해석하고 개선 우선순위를 보강합니다.

**Output(파일 산출물 및 에이전트 응답)**

- 파일 생성: 세션 디렉토리에 `retro.md`가 생성되고(심층 모드에서는 보조 분석 파일 포함) 회고 근거가 저장됩니다.
- 파일 수정: 같은 세션에서 재실행하면 `retro.md`가 최신 분석으로 갱신됩니다.
- 에이전트 응답: 반복 마찰 패턴, 우선순위, 적용 레이어(eval/state/doc)가 함께 정리됩니다.

**샘플 시나리오**

1. 직접 실행:
    - 입력: "이번 세션 끝내기 전에 병목이 뭐였는지 회고 정리해주고, 다음에 바꿀 액션까지 남겨주세요."
    - 결과: `retro.md`에 원인 분석과 후속 액션이 정리됩니다.
2. `cwf:run` 실행:
    - 입력: "이 작업 CWF로 마무리까지 진행해주세요."
    - 결과: `refactor` 이후 `retro`가 실행되어 이번 실행에서의 교훈이 기록됩니다.

### [refactor](plugins/cwf/skills/refactor/SKILL.md)

**의의**

기능·문서·스크립트가 함께 커질 때 발생하는 전역 드리프트를 조기에 정리해 품질 하락을 막고, 코드뿐 아니라 스킬·문서·운영 스크립트를 같은 기준으로 점검해 누적 불일치를 줄입니다.

**Input(입력값)**

- 사용자가 코드/문서/스킬 정합성 점검 또는 정리 실행을 요청할 때 실행됩니다.
- 사용자가 `cwf:run`으로 작업을 요청하면 기본 체인에서 `review(code)` 다음 단계로 실행되어, 출고 전 구조/품질 정리를 수행합니다.

**Process(입력의 처리 방법)**

- 선택한 모드(quick/tidy/contract/deep/docs)에 맞춰 코드·문서·스킬 정합성을 점검합니다.  
- 탐지된 이슈를 근거와 함께 정리하고, 필요한 경우 정리 변경을 반영한 뒤 재검증합니다.
- `--codebase --deep` 모드에서는 고정 전문가 2명과 컨텍스트 전문가 2명의 병렬 렌즈를 추가해 스캔 결과를 심층 검토합니다.

**Output(파일 산출물 및 에이전트 응답)**

- 파일 생성: 모드별 점검/요약 산출물(예: quick scan 결과, refactor summary)이 세션 디렉토리에 생성됩니다.
- 파일 수정: tidy/정리 실행 시 코드·문서·스크립트가 실제로 수정될 수 있습니다.
- 에이전트 응답: 드리프트 이슈가 심각도/영향 범위와 함께 보고되고, 재실행 기준 확인 포인트가 안내됩니다.

**샘플 시나리오**

1. 직접 실행:
    - 입력: "이번 변경 기준으로 코드랑 문서 드리프트 있는지 점검하고, 정리 가능한 건 바로 정리해주세요."
    - 결과: 정합성 이슈 목록과 정리 결과(또는 수정 권고)가 함께 반환됩니다.
2. `cwf:run` 실행:
    - 입력: "신규 기능 작업을 CWF로 끝까지 진행해주세요."
    - 결과: 코드 리뷰 이후 `refactor`가 실행되어 출고 전 정리 단계가 반영됩니다.

### [handoff](plugins/cwf/skills/handoff/SKILL.md)

**의의**

세션/페이즈 경계에서 컨텍스트 손실 없이 다음 실행자가 바로 이어받을 수 있게 만들고, `next-session.md`로 다음 시작점을, `phase-handoff.md`로 계획(WHAT)을 실행하는 제약/프로토콜(HOW)을 전달합니다.

**Input(입력값)**

- 사용자가 세션 종료 전 또는 페이즈 전환 전에 핸드오프 문서 생성을 요청할 때 실행됩니다.
- 사용자가 `cwf:run`으로 작업을 요청해도 기본 체인에는 자동 포함되지 않으며, 중간/종료 시점에 사용자가 요청할 때 수동으로 실행됩니다.

**Process(입력의 처리 방법)**

- 현재 세션 상태와 산출물을 읽어 `next-session.md` 또는 `phase-handoff.md`를 생성합니다.  
- 문서 생성 후 `cwf-state.yaml` 세션 항목을 갱신해 다음 실행자가 같은 컨텍스트에서 시작하도록 고정합니다.

**Output(파일 산출물 및 에이전트 응답)**

- 파일 생성: `next-session.md` 또는 `phase-handoff.md`가 생성되어 다음 실행 시작점이 파일로 고정됩니다.
- 파일 수정: `cwf-state.yaml`의 현재 세션 항목(artifacts/summary/completed/live)이 핸드오프 결과에 맞게 갱신됩니다.
- 에이전트 응답: 재시작 지점, 미해결 항목, phase handoff의 HOW 제약 전달 여부가 요약됩니다.

**샘플 시나리오**

1. 직접 실행:
    - 입력: "오늘은 여기까지 할게요. 다음 세션에서 바로 이어갈 수 있게 핸드오프 문서 만들어주세요."
    - 결과: 다음 세션 재시작 지점과 미해결 항목이 정리된 핸드오프 문서가 생성됩니다.
2. `cwf:run` 실행:
    - 입력: "cwf:run 진행 중인데, 컨텍스트 줄이기 전에 phase handoff 먼저 남겨주세요."
    - 결과: `phase-handoff.md`가 생성되어 프로토콜/제약이 고정되고 이후 단계를 안전하게 이어갈 수 있습니다.

### [ship](plugins/cwf/skills/ship/SKILL.md)

**의의**

이슈/PR/머지 준비를 표준화해 출고 품질을 유지하면서도 최종 승인 책임을 명확히 분리하고, 자동화 가능한 준비 단계는 빠르게 넘기되 머지 최종 판단은 사용자 게이트로 남깁니다.

**Input(입력값)**

- 사용자가 검증된 변경의 이슈/PR/머지 준비를 요청할 때 실행됩니다.
- 사용자가 `cwf:run`으로 작업을 요청하면 기본 체인 마지막 단계에서(사용자 승인 게이트 포함) 실행되어, 출고용 산출물과 남은 리스크를 정리합니다.

**Process(입력의 처리 방법)**

- 검증된 산출물을 바탕으로 `/ship issue`, `/ship pr`, `/ship merge` 흐름을 실행하고 결과를 `ship.md`에 기록합니다.  
- ambiguity debt와 승인/체크 조건을 함께 점검해 머지 가능 여부를 게이트로 판단합니다.

**Output(파일 산출물 및 에이전트 응답)**

- 파일 생성: 세션 디렉토리에 `ship.md` 실행 요약이 생성됩니다.
- 에이전트 응답: 이슈/PR/머지 실행 결과와 차단 조건(예: blocking debt, 승인 필요)이 함께 보고됩니다.

**샘플 시나리오**

1. 직접 실행:
    - 입력: "이번 작업 결과로 PR 초안 만들어주세요. 리뷰어가 바로 판단할 수 있게 변경 근거도 넣어주세요."
    - 결과: PR 본문 초안(또는 생성 결과)과 남은 체크 항목이 함께 제시됩니다.
2. `cwf:run` 실행:
    - 입력: "이 작업 CWF로 끝까지 처리하고, 마지막엔 PR 준비까지 해주세요."
    - 결과: 최종 단계에서 `ship`이 실행되어 출고 산출물과 승인 필요 항목이 정리됩니다.

### [review](plugins/cwf/skills/review/SKILL.md)

**의의**

구현 전후 핵심 시점에 동일한 품질 게이트를 적용해 리스크를 조기에 노출·차단하고, 내부/외부 관점을 병렬로 합성해 단일 시각 편향을 줄이며 결정 품질을 안정화합니다.

**Input(입력값)**

- 사용자가 요구/계획/코드에 대해 품질 검증을 요청할 때 실행됩니다. (지원 범위: `clarify`/`plan`/`code` 모드 리뷰, 병렬 다각도 리뷰, 게이트 판정)
- 사용자가 `cwf:run`으로 작업을 요청하면 기본 체인에서 `plan` 뒤와 `impl` 뒤의 두 지점에서 실행되어 단계별 품질 게이트를 적용합니다.

**Process(입력의 처리 방법)**

- 내부/외부/전문가 슬롯을 병렬 실행해 모드별(`clarify`/`plan`/`code`) 리뷰 근거를 수집합니다.  
- 외부 CLI가 실패하면 Task fallback으로 슬롯을 보완하고, 최종 합성 결과를 `review-synthesis-{mode}.md`로 저장합니다.
- 전문가 슬롯은 `expert_roster`에서 도메인 적합성과 프레임워크 대비를 기준으로 선택해, 일반 리뷰 슬롯과 다른 관점의 근거를 보강합니다.

**Output(파일 산출물 및 에이전트 응답)**

- 파일 생성: 세션 디렉토리에 슬롯별 리뷰 파일(`review-*-{mode}.md`)과 `review-synthesis-{mode}.md`가 생성됩니다.
- 에이전트 응답: 리뷰 모드별(`clarify`/`plan`/`code`) 게이트 판정, 핵심 findings, fallback 적용 여부가 함께 제시됩니다.

**샘플 시나리오**

1. 직접 실행:
    - 입력: "plan.md 기준으로 구현 들어가기 전에 리스크 있는지 먼저 리뷰해주세요."
    - 결과: 계획 품질 게이트 판정과 수정 권고 항목이 반환됩니다.
2. `cwf:run` 실행:
    - 입력: "신규 기능 작업을 CWF로 끝까지 진행해주세요."
    - 결과: `review(plan)`과 `review(code)`가 자동 수행되어 단계별 품질 결과가 남습니다.

### [hitl](plugins/cwf/skills/hitl/SKILL.md)

**의의**

자동 리뷰로 결론 내리기 어려운 지점에 사람 판단을 구조적으로 주입해 검토 품질을 높이고, 긴 diff를 청크 단위로 관리하며 상태를 저장해 중단 후에도 같은 맥락에서 재개할 수 있게 합니다.

**Input(입력값)**

- 사용자가 대형 diff나 정책/선호 이슈에 대한 사람 중심 검토를 요청할 때 실행됩니다.
- 사용자가 `cwf:run`으로 작업을 요청해도 기본 체인에는 자동 포함되지 않으며, 사용자가 중간에 개입 검토를 요청할 때 수동으로 실행됩니다.

**Process(입력의 처리 방법)**

- 합의 라운드로 시작해 diff를 청크 큐로 만들고 `Primary Chunk + Related Context + Causal Lens` 형식으로 순차 검토합니다.  
- 진행 상태·룰·커서를 상태 파일에 지속 저장해 중단 후에도 같은 지점에서 재개합니다.

**Output(파일 산출물 및 에이전트 응답)**

- 파일 생성: `.cwf/projects/{session-dir}/hitl/` 아래 상태 파일(`queue.json`, `state.yaml`, `rules.yaml` 등)이 생성됩니다.
- 파일 수정: 합의된 수정사항 적용 시 대상 코드/문서와 HITL 상태 파일이 함께 갱신됩니다.
- 에이전트 응답: 청크 단위 리뷰 진행상태, 적용 룰, 재개 지점이 일관된 형식으로 안내됩니다.

**샘플 시나리오**

1. 직접 실행:
    - 입력: "이 diff는 제가 직접 판단할 부분이 많아요. hitl로 chunk review 시작해주세요."
    - 결과: 합의 라운드와 청크 리뷰 상태가 생성되고, 재개 가능한 검토 흐름이 시작됩니다.
2. `cwf:run` 실행:
    - 입력: "cwf:run 진행 중인데 여기서부터는 hitl로 검토하면서 가죠."
    - 결과: 자동 체인을 사람 검토 흐름으로 전환해 합의 기반으로 다음 결정을 진행합니다.

### [run](plugins/cwf/skills/run/SKILL.md)

**의의**

개별 스킬 호출을 수동 조합하지 않고 end-to-end 실행을 일관된 게이트 정책으로 위임할 수 있게 하며, pre-impl은 사용자 결정 게이트를 유지하고 post-impl은 자동 체이닝해 통제와 속도를 함께 확보합니다.

**Input(입력값)**

- 사용자가 조사부터 출고 준비까지 전체 작업의 CWF 파이프라인 실행을 요청할 때 실행됩니다.
- 사용자가 `cwf:run`을 명시하면 기본값 기준으로 `gather → clarify → plan → review(plan) → impl → review(code) → refactor → retro → ship` 체인이 순차 실행됩니다.

**Process(입력의 처리 방법)**

- 실행 전 setup readiness를 검사한 뒤 기본 체인을 단계별 게이트와 함께 오케스트레이션합니다.
- pre-impl 단계는 사용자 결정을 보장하고, post-impl 단계는 자동 체이닝하며 run 상태/증빙 파일을 지속 갱신합니다.
- `--from`/`--skip` 옵션과 run-closing artifact gate를 반영해 단계 실행/종료 여부를 판정합니다.

**Output(파일 산출물 및 에이전트 응답)**

- 파일 생성: 세션 디렉토리에 `run-stage-provenance.md` 등 run 추적 산출물이 생성됩니다.
- 파일 수정: 파이프라인 진행에 따라 각 단계 산출물과 `cwf-state.yaml`의 run 상태 정보가 순차적으로 갱신됩니다.
- 에이전트 응답: 단계별 진행 상태, 게이트 통과/보류 사유, 사용자 결정 필요 지점이 요약됩니다.

**샘플 시나리오**

1. 직접 실행:
    - 입력: "이 버그 이슈를 조사부터 수정, 리뷰, PR 준비까지 CWF로 진행해주세요."
    - 결과: 단계별 산출물이 순서대로 생성되고, 각 게이트 결과와 함께 작업이 진행됩니다.
2. `cwf:run` 실행:
    - 입력: "이 작업 `cwf:run`으로 진행하고, 중요한 선택지는 중간에 꼭 물어봐주세요."
    - 결과: 파이프라인이 자동 실행되되, 사용자 판단이 필요한 지점에서 질문이 발생합니다.

### [setup](plugins/cwf/skills/setup/SKILL.md)

**의의**

초기 실행 환경을 표준화해 이후 워크플로우를 재현 가능하게 만들고 도구/의존성 누락으로 인한 실패를 줄이며, 한 번 정해둔 훅/도구/설정 계약을 재사용해 세션마다 같은 기준으로 시작할 수 있게 합니다.

**Input(입력값)**

- 사용자가 새 저장소의 CWF 초기 설정 또는 기존 환경 점검/정렬을 요청할 때 실행됩니다. (지원 범위: 훅 설정, 의존성 점검, 설정 파일 부트스트랩, 선택적 Codex 연동)
- 사용자가 `cwf:run`을 요청했는데 setup 선행 조건이 없으면 run preflight/워크플로우 게이트에서 setup 선행을 요구합니다.

**Process(입력의 처리 방법)**

- 실행 모드(`cwf:setup`, `--hooks`, `--tools` 등)와 사용자 선택에 따라 훅, 도구 점검, 설정 부트스트랩, 선택 연동(Codex/인덱스/게이트)을 순차 실행합니다.  
- 사용자 선택을 반영해 설정·계약 파일을 생성/갱신하고 이후 워크플로우 기준 상태를 고정합니다.

**Output(파일 산출물 및 에이전트 응답)**

- 파일 생성: `.cwf-config.yaml`, `.cwf-config.local.yaml`, 인덱스/계약 파일 등 기준 설정 아티팩트가 생성될 수 있습니다.
- 파일 수정: 훅 설정, 런모드 설정, Codex 링크/래퍼 등 기존 설정이 선택값에 맞게 갱신됩니다.
- 에이전트 응답: 감지된 의존성 상태, 설치/설정 선택 결과, 스코프별 연동 상태가 보고됩니다.
- Codex 세부 실행 계약은 setup 스킬 문서에서 관리하고, README는 목적/효과 요약만 유지합니다.

**샘플 시나리오**

1. 직접 실행:
    - 입력: "새 저장소에 CWF 붙였어요. setup부터 표준 설정으로 맞춰주시고 Codex 연동도 같이 해주세요."
    - 결과: 설정 파일, 의존성 점검 결과, 연동 상태가 한 번에 정리됩니다.
2. `cwf:run` 실행:
    - 입력: "이 저장소 작업을 CWF로 바로 돌려주세요."
    - 결과: setup 선행 조건이 없으면 먼저 setup 안내/실행을 거친 뒤 run 단계로 진입합니다.

### [update](plugins/cwf/skills/update/SKILL.md)

**의의**

설치된 CWF를 최신 계약/수정사항과 정렬 상태로 유지해 구버전 동작 차이로 인한 혼선을 줄이고, 스코프별 정렬과 fail-closed 검증으로 버전은 같아도 계약이 어긋난 상태를 예방합니다.

**Input(입력값)**

- 사용자가 현재 설치 버전 점검 또는 업데이트 적용을 요청할 때 실행됩니다.
- 사용자가 `cwf:run`을 요청해도 기본 체인에는 자동 포함되지 않으며, 실행 전/후에 사용자가 명시할 때 선행 또는 후행으로 실행됩니다.

**Process(입력의 처리 방법)**

- 업데이트 대상 스코프를 먼저 확정하고 최신 버전 일치 여부를 검증합니다.  
- `UNVERIFIED`는 fail-closed로 중단하고, 검증되면 업데이트 적용(또는 check 보고)과 Codex 경로 재정렬까지 수행합니다.

**Output(파일 산출물 및 에이전트 응답)**

- 파일 수정: 새 버전이 있으면 선택 스코프의 CWF 설치 상태가 갱신되고(체크 모드 제외), 필요 시 Codex symlink/wrapper 경로가 재정렬됩니다.
- 에이전트 응답: 버전 비교 결과, `--check`(조회 전용)와 업데이트 적용 실행의 차이, `UNVERIFIED` fail-closed 판정이 명시됩니다.

**샘플 시나리오**

1. 직접 실행:
    - 입력: "현재 CWF 최신인지 확인하고, 새 버전 있으면 바로 업데이트해주세요."
    - 결과: 버전 비교 결과와 업데이트 적용 여부가 스코프 기준으로 보고됩니다.
2. `cwf:run` 실행:
    - 입력: "작업은 cwf:run으로 할 건데, 시작 전에 CWF 버전부터 최신으로 맞춰주세요."
    - 결과: 먼저 `update`로 버전을 정렬한 뒤 `run` 체인 실행을 시작할 수 있습니다.

### Codex 연동

Codex 연동은 `cwf:setup`의 선택 기능입니다.

- What: 활성 스코프에 CWF 스킬/레퍼런스를 연결하고, 필요하면 Codex 래퍼를 설치합니다.
- Why: Claude Code와 Codex가 같은 CWF 지식을 공유하고, Codex 세션 로그를 CWF 아티팩트로 남길 수 있게 합니다.
- Codex 연동만 다시 적용하려면:

```text
cwf:setup --codex
cwf:setup --codex-wrapper
```

세부 실행 플로우, 스코프/경로 매트릭스, 롤백/검증 명령은 아래 문서에 있습니다.
- [plugins/cwf/skills/setup/SKILL.md](plugins/cwf/skills/setup/SKILL.md)
- [plugins/cwf/skills/setup/references/codex-scope-integration.md](plugins/cwf/skills/setup/references/codex-scope-integration.md)
- [plugins/cwf/scripts/README.md](plugins/cwf/scripts/README.md)

## 훅

CWF는 Claude Code에서 자동 실행되는 9개 훅 그룹을 포함합니다. Codex CLI에서는 Claude 훅 런타임이 직접 실행되지 않으며, Codex 래퍼 연동으로 일부 항목만 부분 대체됩니다.

| 그룹 | 훅 유형 | 하는 일 | Codex 연동 |
|------|---------|---------|-------------|
| `attention` | Notification, Pre/PostToolUse | 유휴 상태 및 AskUserQuestion 시 Slack 알림 | 직접 대응되는 자동 훅 없음 |
| `log` | Stop, SessionEnd | 대화 턴을 마크다운으로 자동 기록 | `cwf:setup --codex-wrapper`로 Codex 세션을 `.cwf/sessions/*.codex.md`로 export |
| `read` | PreToolUse → Read | 파일 크기 인식 읽기 가드 (500줄 이상 경고, 2000줄 이상 차단) | 직접 대응되는 자동 훅 없음 |
| `lint_markdown` | PostToolUse → Write\|Edit | 마크다운 린트 + 로컬 링크 검증 -- 린트 위반 시 자동 수정 유도, 깨진 링크 비동기 보고 | 래퍼 post-run 점검으로 변경된 마크다운 파일 대상 부분 대체 |
| `lint_shell` | PostToolUse → Write\|Edit | 셸 스크립트용 ShellCheck 검증 | 래퍼 post-run 점검으로 변경된 셸 파일 대상 부분 대체(`shellcheck` 설치 시) |
| `deletion_safety` | PreToolUse → Bash | 위험한 삭제 명령을 차단하고 정책 준수 근거를 요구 | 직접 대응되는 자동 훅 없음 |
| `workflow_gate` | UserPromptSubmit | setup 선행 조건이 없으면 `cwf:run`을 차단하고, `cwf:run` 게이트가 남아 있으면 ship/push/merge 의도를 차단 | 직접 대응되는 자동 훅 없음 |
| `websearch_redirect` | PreToolUse → WebSearch | Claude의 WebSearch를 `cwf:gather --search`로 리다이렉트 | 직접 대응되는 자동 훅 없음 |
| `compact_recovery` | SessionStart → compact, UserPromptSubmit | auto-compact 후 라이브 상태를 주입하고, 프롬프트 제출 시 세션-워크트리 바인딩 불일치를 차단 | 직접 대응되는 자동 훅 없음 |

## 환경 설정

CWF 런타임은 아래 우선순위로 설정을 읽습니다.

1. `.cwf-config.local.yaml` (로컬/비밀값, 최고 우선순위)
2. `.cwf-config.yaml` (팀 공유 기본값)
3. 프로세스 환경 변수
4. 셸 프로파일(`~/.zshenv`, `~/.zprofile`, `~/.zshrc`, `~/.bash_profile`, `~/.bashrc`, `~/.profile`)

`cwf:setup`을 수행하면 프로젝트 설정 템플릿을 부트스트랩하고, `.cwf-config.local.yaml`을 `.gitignore`에 등록합니다.

팀 공유 기본값은 `.cwf-config.yaml`에 두세요.

```yaml
# .cwf-config.yaml
# Optional artifact path overrides
# CWF_ARTIFACT_ROOT: ".cwf"
# CWF_PROJECTS_DIR: ".cwf/projects"
# CWF_STATE_FILE: ".cwf/cwf-state.yaml"

# Optional runtime overrides (non-secret)
# CWF_GATHER_OUTPUT_DIR: ".cwf/projects"
# CWF_READ_WARN_LINES: 500
# CWF_READ_DENY_LINES: 2000
# CWF_SESSION_LOG_DIR: ".cwf/sessions"
# CWF_SESSION_LOG_ENABLED: true
# CWF_SESSION_LOG_TRUNCATE: 10
# CWF_SESSION_LOG_AUTO_COMMIT: false
```

개인/비밀값은 `.cwf-config.local.yaml`에 두세요.

```yaml
# .cwf-config.local.yaml
SLACK_BOT_TOKEN: "xoxb-your-bot-token"
SLACK_CHANNEL_ID: "D0123456789"
TAVILY_API_KEY: "tvly-your-key"
EXA_API_KEY: "your-key"
# SLACK_WEBHOOK_URL: "https://hooks.slack.com/services/..."
```

프로젝트별 설정 파일을 쓰지 않거나, 전역 기본값을 유지하려면 쉘 프로파일을 통한 환경 변수 방식을 사용하시면 됩니다.

```bash
# 필수 — Slack 알림(attention 훅)
SLACK_BOT_TOKEN="xoxb-your-bot-token"            # chat:write + im:write 스코프를 가진 Slack App
SLACK_CHANNEL_ID="D0123456789"                   # 봇 DM 채널 ID (또는 C...로 시작하는 채널 ID)
# SLACK_WEBHOOK_URL="https://hooks.slack.com/services/..."  # 선택: 웹훅 폴백(스레딩 없음)

# 필수 — 검색 API(gather)
TAVILY_API_KEY="tvly-..."                        # 웹 검색 및 URL 추출 (https://app.tavily.com)
EXA_API_KEY="..."                                # 코드 검색 (https://dashboard.exa.ai)

# 오버라이드 — attention
CWF_ATTENTION_DELAY=45                           # 기본값: 30
CWF_ATTENTION_REPLY_BROADCAST=true               # 기본값: false
CWF_ATTENTION_TRUNCATE=20                        # 기본값: 10
CWF_ATTENTION_USER_ID="U0123456789"              # 기본값: 미설정
# CWF_ATTENTION_USER_HANDLE="your-handle"        # 기본값: 미설정
# CWF_ATTENTION_PARENT_MENTION="<@U0123456789>"  # 기본값: 미설정

# 오버라이드 — gather/read/session-log
CWF_GATHER_OUTPUT_DIR=".cwf/projects"               # 기본값: .cwf/projects
CWF_READ_WARN_LINES=700                             # 기본값: 500
CWF_READ_DENY_LINES=2500                            # 기본값: 2000
CWF_SESSION_LOG_DIR=".cwf/sessions"                 # 기본값: .cwf/sessions
CWF_SESSION_LOG_ENABLED=false                       # 기본값: true
CWF_SESSION_LOG_TRUNCATE=20                         # 기본값: 10
CWF_SESSION_LOG_AUTO_COMMIT=true                    # 기본값: false

# 오버라이드 — 아티팩트 경로(고급)
# CWF_ARTIFACT_ROOT=".cwf-data"                     # 기본값: .cwf
# CWF_PROJECTS_DIR=".cwf/projects"                  # 기본값: {CWF_ARTIFACT_ROOT}/projects
# CWF_STATE_FILE=".cwf/custom-state.yaml"           # 기본값: {CWF_ARTIFACT_ROOT}/cwf-state.yaml
```

v3 이전 환경변수(`CLAUDE_CORCA_*`, `CLAUDE_ATTENTION_*`)를 사용 중이라면 필요한 값을 현재 `CWF_*` 키로 수동 이전한 뒤, 아래 명령으로 상태를 확인하세요.

```bash
bash plugins/cwf/scripts/check-setup-readiness.sh --base-dir . --summary
```

## 라이선스

MIT
