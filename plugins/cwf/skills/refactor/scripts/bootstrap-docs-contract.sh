#!/usr/bin/env bash
set -euo pipefail

# bootstrap-docs-contract.sh — Create/refresh repository-local docs review contract.
#
# Usage:
#   bootstrap-docs-contract.sh [--contract <path>] [--force] [--json]
#
# Behavior:
# - Default contract location: {artifact_root}/docs-contract.yaml
# - Artifact root resolution: CWF config/env via cwf-artifact-paths.sh, fallback ./.cwf
# - Idempotent by default: existing contract is never overwritten unless --force
# - On bootstrap failure, emit fallback metadata and return success so docs review can continue

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
RESOLVER_SCRIPT="$SCRIPT_DIR/../../../scripts/cwf-artifact-paths.sh"

CONTRACT_PATH=""
FORCE="false"
JSON_OUTPUT="false"
WARNING=""

usage() {
  cat <<'USAGE'
bootstrap-docs-contract.sh — bootstrap docs review contract

Usage:
  bootstrap-docs-contract.sh [options]

Options:
  --contract <path>  Explicit contract path (default: {artifact_root}/docs-contract.yaml)
  --force            Overwrite existing contract file
  --json             Print machine-readable result
  -h, --help         Show this help
USAGE
}

json_escape() {
  local value="$1"
  value="${value//\\/\\\\}"
  value="${value//\"/\\\"}"
  value="${value//$'\n'/ }"
  printf '%s' "$value"
}

append_warning() {
  local message="$1"
  if [[ -z "$WARNING" ]]; then
    WARNING="$message"
  else
    WARNING="$WARNING; $message"
  fi
}

emit_result() {
  local status="$1"
  local path="$2"
  local artifact_root="$3"
  local warning="${4-}"

  if [[ "$JSON_OUTPUT" == "true" ]]; then
    if [[ -n "$warning" ]]; then
      printf '{"status":"%s","path":"%s","artifact_root":"%s","warning":"%s"}\n' \
        "$status" \
        "$(json_escape "$path")" \
        "$(json_escape "$artifact_root")" \
        "$(json_escape "$warning")"
    else
      printf '{"status":"%s","path":"%s","artifact_root":"%s"}\n' \
        "$status" \
        "$(json_escape "$path")" \
        "$(json_escape "$artifact_root")"
    fi
  else
    echo "status: $status"
    echo "path: $path"
    echo "artifact_root: $artifact_root"
    if [[ -n "$warning" ]]; then
      echo "warning: $warning"
    fi
  fi
}

resolve_artifact_root() {
  local resolved=""

  if [[ ! -f "$RESOLVER_SCRIPT" ]]; then
    return 1
  fi

  # Run resolver in a subshell so shell options from sourced script do not leak.
  if resolved="$(
    bash -c 'source "$1" && resolve_cwf_artifact_root "$2"' _ "$RESOLVER_SCRIPT" "$REPO_ROOT" 2>/dev/null
  )"; then
    if [[ -n "$resolved" ]]; then
      printf '%s\n' "$resolved"
      return 0
    fi
  fi

  return 1
}

path_to_abs() {
  local path_value="$1"
  if [[ "$path_value" == /* ]]; then
    printf '%s\n' "$path_value"
  else
    printf '%s\n' "$REPO_ROOT/$path_value"
  fi
}

emit_list_or_empty() {
  local indent="$1"
  shift
  if [[ $# -eq 0 ]]; then
    printf '%s[]\n' "$indent"
    return 0
  fi

  echo
  local item=""
  for item in "$@"; do
    printf '%s- "%s"\n' "$indent" "$item"
  done
}

write_contract_file() {
  local destination="$1"
  local generated_at_utc="$2"
  local locale_enabled="$3"
  local project_context_enabled="$4"
  local inventory_enabled="$5"
  local project_context_path="$6"
  local plugin_inventory_path="$7"
  local plugin_manifests_glob="$8"
  shift 8
  local required_docs_count="$1"
  shift
  local optional_docs_count="$1"
  shift
  local required_entry_docs=("${@:1:$required_docs_count}")
  shift "$required_docs_count"
  local optional_entry_docs=("${@:1:$optional_docs_count}")

  {
    echo 'version: 1'
    printf 'generated_at_utc: "%s"\n' "$generated_at_utc"
    echo 'mode: "advisory"'
    echo
    echo 'entry_docs:'
    printf '  required: '
    emit_list_or_empty '    ' "${required_entry_docs[@]}"
    printf '  optional: '
    emit_list_or_empty '    ' "${optional_entry_docs[@]}"
    echo
    echo 'inventory:'
    printf '  project_context_path: "%s"\n' "$project_context_path"
    printf '  plugin_inventory_path: "%s"\n' "$plugin_inventory_path"
    printf '  plugin_manifest_glob: "%s"\n' "$plugin_manifests_glob"
    echo
    echo 'locale_mirrors:'
    echo '  - primary: "README.md"'
    echo '    mirror: "README.ko.md"'
    printf '    enabled: %s\n' "$locale_enabled"
    echo
    echo 'checks:'
    echo '  portability_baseline: true'
    echo '  entry_docs_review: true'
    printf '  project_context_review: %s\n' "$project_context_enabled"
    printf '  inventory_alignment: %s\n' "$inventory_enabled"
    printf '  locale_mirror_alignment: %s\n' "$locale_enabled"
    echo
    echo 'reporting:'
    echo '  include_contract_metadata: true'
    echo '  include_skipped_checks: true'
    echo
    echo 'notes:'
    echo '  - "Auto-generated by refactor docs contract bootstrap."'
    echo '  - "Review this draft before enforcing repository-specific checks."'
  } > "$destination"
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --contract)
      CONTRACT_PATH="${2-}"
      if [[ -z "$CONTRACT_PATH" ]]; then
        echo "Error: --contract requires a path value" >&2
        exit 1
      fi
      shift 2
      ;;
    --force)
      FORCE="true"
      shift
      ;;
    --json)
      JSON_OUTPUT="true"
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      echo "Error: unknown option: $1" >&2
      usage >&2
      exit 1
      ;;
  esac
done

ARTIFACT_ROOT_RAW=""
if ! ARTIFACT_ROOT_RAW="$(resolve_artifact_root)"; then
  ARTIFACT_ROOT_RAW=".cwf"
  append_warning "artifact root resolver unavailable; using .cwf fallback"
fi
ARTIFACT_ROOT_ABS="$(path_to_abs "$ARTIFACT_ROOT_RAW")"

if [[ -z "$CONTRACT_PATH" ]]; then
  CONTRACT_PATH="$ARTIFACT_ROOT_ABS/docs-contract.yaml"
else
  CONTRACT_PATH="$(path_to_abs "$CONTRACT_PATH")"
fi

if ! mkdir -p "$(dirname "$CONTRACT_PATH")" 2>/dev/null; then
  append_warning "unable to create contract directory; continue with fallback defaults"
  emit_result "fallback" "$CONTRACT_PATH" "$ARTIFACT_ROOT_ABS" "$WARNING"
  exit 0
fi

if [[ -f "$CONTRACT_PATH" && "$FORCE" != "true" ]]; then
  emit_result "existing" "$CONTRACT_PATH" "$ARTIFACT_ROOT_ABS" "$WARNING"
  exit 0
fi

required_entry_docs=()
optional_entry_docs=()

if [[ -f "$REPO_ROOT/AGENTS.md" ]]; then
  required_entry_docs+=("AGENTS.md")
fi
if [[ -f "$REPO_ROOT/README.md" ]]; then
  required_entry_docs+=("README.md")
fi
if [[ -f "$REPO_ROOT/CLAUDE.md" ]]; then
  optional_entry_docs+=("CLAUDE.md")
fi
if [[ -f "$REPO_ROOT/README.ko.md" ]]; then
  optional_entry_docs+=("README.ko.md")
fi

project_context_path=""
if [[ -f "$REPO_ROOT/docs/project-context.md" ]]; then
  project_context_path="docs/project-context.md"
fi

plugin_inventory_path=""
if [[ -f "$REPO_ROOT/.claude-plugin/marketplace.json" ]]; then
  plugin_inventory_path=".claude-plugin/marketplace.json"
fi

plugin_manifests_glob=""
if [[ -d "$REPO_ROOT/plugins" ]]; then
  plugin_manifests_glob="plugins/*/.claude-plugin/plugin.json"
fi

locale_enabled="false"
if [[ -f "$REPO_ROOT/README.md" && -f "$REPO_ROOT/README.ko.md" ]]; then
  locale_enabled="true"
fi

project_context_enabled="false"
if [[ -n "$project_context_path" ]]; then
  project_context_enabled="true"
fi

inventory_enabled="false"
if [[ -n "$plugin_inventory_path" ]]; then
  inventory_enabled="true"
fi

generated_at_utc="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
tmp_file="$(mktemp "$CONTRACT_PATH.tmp.XXXXXX" 2>/dev/null || true)"
if [[ -z "$tmp_file" ]]; then
  append_warning "unable to allocate temporary file for contract generation"
  emit_result "fallback" "$CONTRACT_PATH" "$ARTIFACT_ROOT_ABS" "$WARNING"
  exit 0
fi

if ! write_contract_file \
  "$tmp_file" \
  "$generated_at_utc" \
  "$locale_enabled" \
  "$project_context_enabled" \
  "$inventory_enabled" \
  "$project_context_path" \
  "$plugin_inventory_path" \
  "$plugin_manifests_glob" \
  "${#required_entry_docs[@]}" \
  "${#optional_entry_docs[@]}" \
  "${required_entry_docs[@]}" \
  "${optional_entry_docs[@]}"; then
  mv "$tmp_file" "$tmp_file.failed" >/dev/null 2>&1 || true
  append_warning "failed to render contract draft; continue with fallback defaults"
  emit_result "fallback" "$CONTRACT_PATH" "$ARTIFACT_ROOT_ABS" "$WARNING"
  exit 0
fi

if ! mv "$tmp_file" "$CONTRACT_PATH" 2>/dev/null; then
  mv "$tmp_file" "$tmp_file.failed" >/dev/null 2>&1 || true
  append_warning "failed to write contract file; continue with fallback defaults"
  emit_result "fallback" "$CONTRACT_PATH" "$ARTIFACT_ROOT_ABS" "$WARNING"
  exit 0
fi

if [[ "$FORCE" == "true" ]]; then
  emit_result "updated" "$CONTRACT_PATH" "$ARTIFACT_ROOT_ABS" "$WARNING"
else
  emit_result "created" "$CONTRACT_PATH" "$ARTIFACT_ROOT_ABS" "$WARNING"
fi
