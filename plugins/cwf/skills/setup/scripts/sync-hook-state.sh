#!/usr/bin/env bash
set -euo pipefail

# sync-hook-state.sh
# Deterministically sync setup hook selections across:
#   1) ~/.claude/cwf-hooks-enabled.sh
#   2) .cwf/cwf-state.yaml hooks section
#
# Usage:
#   sync-hook-state.sh --enable <group1,group2,...> [--state-file <path>] [--hook-config <path>] [--base-dir <path>]
#   sync-hook-state.sh --check [--state-file <path>] [--hook-config <path>] [--base-dir <path>]

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ARTIFACT_PATHS_SCRIPT="$SCRIPT_DIR/../../../scripts/cwf-artifact-paths.sh"

MODE="apply"
ENABLED_CSV=""
BASE_DIR="."
STATE_FILE=""
HOOK_CONFIG="$HOME/.claude/cwf-hooks-enabled.sh"

HOOK_GROUPS=(
  attention
  log
  read
  lint_markdown
  lint_shell
  deletion_safety
  workflow_gate
  websearch_redirect
  compact_recovery
)

SELECTED_GROUPS=()

usage() {
  cat <<'USAGE'
sync-hook-state.sh â€” synchronize hook toggle state

Usage:
  sync-hook-state.sh --enable <group1,group2,...> [options]
  sync-hook-state.sh --check [options]

Options:
  --enable <csv>        Enabled hook groups (apply mode)
  --check               Verify hook-config and cwf-state hooks parity
  --state-file <path>   Override cwf-state.yaml path
  --hook-config <path>  Override hook config path (default: ~/.claude/cwf-hooks-enabled.sh)
  --base-dir <path>     Base directory for resolving default state path (default: .)
  -h, --help            Show this help

Supported groups:
  attention, log, read, lint_markdown, lint_shell,
  deletion_safety, workflow_gate, websearch_redirect, compact_recovery
USAGE
}

trim_ws() {
  local value="$1"
  value="${value#"${value%%[![:space:]]*}"}"
  value="${value%"${value##*[![:space:]]}"}"
  printf '%s' "$value"
}

to_abs_path() {
  local base_abs="$1"
  local path="$2"
  if [[ "$path" == "~"* ]]; then
    path="${path/#\~/$HOME}"
  fi
  if [[ "$path" == /* ]]; then
    printf '%s\n' "$path"
  else
    printf '%s\n' "$base_abs/$path"
  fi
}

array_contains() {
  local needle="$1"
  shift || true
  local item=""
  for item in "$@"; do
    if [[ "$item" == "$needle" ]]; then
      return 0
    fi
  done
  return 1
}

is_supported_group() {
  local candidate="$1"
  array_contains "$candidate" "${HOOK_GROUPS[@]}"
}

group_enabled() {
  local group="$1"
  if array_contains "$group" "${SELECTED_GROUPS[@]}"; then
    printf 'true\n'
  else
    printf 'false\n'
  fi
}

normalize_bool() {
  local raw="$1"
  raw="$(trim_ws "$raw")"
  raw="${raw%\"}"
  raw="${raw#\"}"
  case "$raw" in
    true|TRUE|True|1|yes|on)
      printf 'true\n'
      ;;
    false|FALSE|False|0|no|off)
      printf 'false\n'
      ;;
    *)
      printf '\n'
      ;;
  esac
}

parse_selected_groups() {
  local csv="$1"
  local token=""
  local parsed=()
  local -a raw_tokens=()
  IFS=',' read -r -a raw_tokens <<<"$csv"

  for token in "${raw_tokens[@]}"; do
    token="$(trim_ws "$token")"
    [[ -n "$token" ]] || continue
    if ! is_supported_group "$token"; then
      echo "CHECK_FAIL: unsupported hook group: $token" >&2
      exit 1
    fi
    if ! array_contains "$token" "${parsed[@]}"; then
      parsed+=("$token")
    fi
  done

  SELECTED_GROUPS=("${parsed[@]}")
}

resolve_state_file() {
  local base_abs="$1"
  local resolved=""

  if [[ -n "$STATE_FILE" ]]; then
    STATE_FILE="$(to_abs_path "$base_abs" "$STATE_FILE")"
    return 0
  fi

  if [[ -f "$ARTIFACT_PATHS_SCRIPT" ]]; then
    # shellcheck source=plugins/cwf/scripts/cwf-artifact-paths.sh
    source "$ARTIFACT_PATHS_SCRIPT"
    resolved="$(resolve_cwf_state_file "$base_abs" 2>/dev/null || true)"
  fi

  if [[ -z "$resolved" ]]; then
    resolved="$base_abs/.cwf/cwf-state.yaml"
  fi

  STATE_FILE="$resolved"
}

render_hook_config() {
  local group=""
  local enabled=""
  local upper=""
  echo "# Generated by cwf:setup"
  for group in "${HOOK_GROUPS[@]}"; do
    enabled="$(group_enabled "$group")"
    upper="$(printf '%s' "$group" | tr '[:lower:]' '[:upper:]')"
    echo "export HOOK_${upper}_ENABLED=\"$enabled\""
  done
}

render_hooks_block() {
  local group=""
  local enabled=""
  echo "hooks:"
  for group in "${HOOK_GROUPS[@]}"; do
    enabled="$(group_enabled "$group")"
    echo "  $group: $enabled"
  done
}

write_hook_config() {
  local hook_config_path="$1"
  local tmp_file=""
  mkdir -p "$(dirname "$hook_config_path")"
  tmp_file="$(mktemp "${hook_config_path}.tmp.XXXXXX")"
  render_hook_config > "$tmp_file"
  mv "$tmp_file" "$hook_config_path"
  chmod 600 "$hook_config_path" 2>/dev/null || true
}

replace_hooks_section() {
  local state_file_path="$1"
  local block_file="$2"
  local tmp_file=""

  if [[ ! -f "$state_file_path" ]]; then
    mkdir -p "$(dirname "$state_file_path")"
    {
      cat "$block_file"
      echo ""
      echo "sessions: []"
    } > "$state_file_path"
    return 0
  fi

  tmp_file="$(mktemp "${state_file_path}.tmp.XXXXXX")"
  awk -v block_file="$block_file" '
    function emit_block(   line) {
      while ((getline line < block_file) > 0) {
        print line
      }
      close(block_file)
    }
    BEGIN {
      in_hooks = 0
      replaced = 0
    }
    {
      if (in_hooks) {
        if ($0 ~ /^[^[:space:]]/) {
          emit_block()
          replaced = 1
          in_hooks = 0
          print $0
        }
        next
      }
      if ($0 ~ /^hooks:[[:space:]]*$/) {
        in_hooks = 1
        next
      }
      print $0
    }
    END {
      if (in_hooks || !replaced) {
        if (NR > 0) {
          print ""
        }
        emit_block()
      }
    }
  ' "$state_file_path" > "$tmp_file"

  mv "$tmp_file" "$state_file_path"
}

ensure_sessions_section() {
  local state_file_path="$1"
  if grep -Eq '^sessions:[[:space:]]*' "$state_file_path"; then
    return 0
  fi
  printf '\nsessions: []\n' >> "$state_file_path"
}

read_state_hook_value() {
  local state_file_path="$1"
  local key="$2"
  awk -v key="$key" '
    /^hooks:[[:space:]]*$/ { in_hooks=1; next }
    in_hooks && /^[^[:space:]]/ { exit }
    in_hooks {
      pat = "^[[:space:]]{2}" key ":[[:space:]]*"
      if ($0 ~ pat) {
        sub(pat, "", $0)
        gsub(/[[:space:]]+$/, "", $0)
        print $0
        exit
      }
    }
  ' "$state_file_path"
}

read_config_hook_value() {
  local hook_config_path="$1"
  local key="$2"
  local upper=""
  upper="$(printf '%s' "$key" | tr '[:lower:]' '[:upper:]')"
  awk -v var="HOOK_${upper}_ENABLED" '
    $1 == "export" && $2 ~ "^" var "=" {
      value = $2
      sub("^" var "=", "", value)
      gsub(/^"/, "", value)
      gsub(/"$/, "", value)
      print value
      exit
    }
  ' "$hook_config_path"
}

run_check() {
  local fail_count=0
  local group=""
  local upper=""
  local state_raw=""
  local config_raw=""
  local state_norm=""
  local config_norm=""

  [[ -f "$STATE_FILE" ]] || {
    echo "CHECK_FAIL: state file not found: $STATE_FILE" >&2
    return 1
  }
  [[ -f "$HOOK_CONFIG" ]] || {
    echo "CHECK_FAIL: hook config not found: $HOOK_CONFIG" >&2
    return 1
  }

  for group in "${HOOK_GROUPS[@]}"; do
    upper="$(printf '%s' "$group" | tr '[:lower:]' '[:upper:]')"
    state_raw="$(read_state_hook_value "$STATE_FILE" "$group")"
    config_raw="$(read_config_hook_value "$HOOK_CONFIG" "$group")"
    state_norm="$(normalize_bool "$state_raw")"
    config_norm="$(normalize_bool "$config_raw")"

    if [[ -z "$state_norm" ]]; then
      echo "CHECK_FAIL: invalid or missing hooks.$group in state file: ${state_raw:-<empty>}" >&2
      fail_count=$((fail_count + 1))
      continue
    fi
    if [[ -z "$config_norm" ]]; then
      echo "CHECK_FAIL: invalid or missing HOOK_${upper}_ENABLED in hook config: ${config_raw:-<empty>}" >&2
      fail_count=$((fail_count + 1))
      continue
    fi
    if [[ "$state_norm" != "$config_norm" ]]; then
      echo "CHECK_FAIL: mismatch for $group (state=$state_norm config=$config_norm)" >&2
      fail_count=$((fail_count + 1))
    fi
  done

  if [[ "$fail_count" -gt 0 ]]; then
    return 1
  fi

  echo "CHECK_OK: hook state synchronized ($STATE_FILE <-> $HOOK_CONFIG)"
  return 0
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --enable)
      ENABLED_CSV="${2-}"
      [[ -n "$ENABLED_CSV" ]] || {
        echo "CHECK_FAIL: --enable requires a CSV value" >&2
        exit 1
      }
      shift 2
      ;;
    --check)
      MODE="check"
      shift
      ;;
    --state-file)
      STATE_FILE="${2-}"
      [[ -n "$STATE_FILE" ]] || {
        echo "CHECK_FAIL: --state-file requires a path" >&2
        exit 1
      }
      shift 2
      ;;
    --hook-config)
      HOOK_CONFIG="${2-}"
      [[ -n "$HOOK_CONFIG" ]] || {
        echo "CHECK_FAIL: --hook-config requires a path" >&2
        exit 1
      }
      shift 2
      ;;
    --base-dir)
      BASE_DIR="${2-}"
      [[ -n "$BASE_DIR" ]] || {
        echo "CHECK_FAIL: --base-dir requires a path" >&2
        exit 1
      }
      shift 2
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      echo "CHECK_FAIL: unknown option: $1" >&2
      usage >&2
      exit 1
      ;;
  esac
done

BASE_ABS="$(cd "$BASE_DIR" && pwd)"
HOOK_CONFIG="$(to_abs_path "$BASE_ABS" "$HOOK_CONFIG")"
resolve_state_file "$BASE_ABS"

if [[ "$MODE" == "check" ]]; then
  run_check
  exit $?
fi

if [[ -z "$ENABLED_CSV" ]]; then
  echo "CHECK_FAIL: apply mode requires --enable <group1,group2,...>" >&2
  exit 1
fi

parse_selected_groups "$ENABLED_CSV"
write_hook_config "$HOOK_CONFIG"

mkdir -p "$(dirname "$STATE_FILE")"
hooks_block_file="$(mktemp "${STATE_FILE}.hooks.XXXXXX")"
render_hooks_block > "$hooks_block_file"
replace_hooks_section "$STATE_FILE" "$hooks_block_file"
rm -f "$hooks_block_file"
ensure_sessions_section "$STATE_FILE"

if ! run_check; then
  exit 1
fi

echo "state_file: $STATE_FILE"
echo "hook_config: $HOOK_CONFIG"
echo "enabled_groups: ${SELECTED_GROUPS[*]}"
