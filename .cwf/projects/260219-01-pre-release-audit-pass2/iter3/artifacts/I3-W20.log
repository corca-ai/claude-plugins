I3-W20 worktree-compact drift analysis
Date: 2026-02-20

[CASE 1] track-user-input guard-only with session_id present + mismatched worktree
Command result:
CASE1_RC=0
CASE1_OUT={"decision":"block","reason":"BLOCKED: session S-TEST is bound to worktree /tmp/cwf-i3-w20-aYLAhl/repo (branch: main) (recorded at epoch 1700000000), but current worktree is /tmp/cwf-i3-w20-aYLAhl/wt. Switch to the bound worktree before continuing."}

[CASE 2] track-user-input guard-only with empty session_id + mismatched worktree
Command result:
CASE2_RC=0
CASE2_OUT={"decision":"block","reason":"BLOCKED: missing session_id in guard mode while sessionâ†”worktree bindings exist. Retry from the bound session/worktree context."}

[CASE 3] compact-context fallback with live.worktree_root populated (session_id empty input)
Command result:
CASE3_RC=0
Observed context lines:
1:[Compact Recovery] Session: S-TEST | Phase: impl
5:Expected worktree: /tmp/cwf-i3-w20-aYLAhl/repo
6:Expected worktree branch: main
8:[WORKTREE ALERT] Current worktree (/tmp/cwf-i3-w20-aYLAhl/wt) does not match bound session worktree (/tmp/cwf-i3-w20-aYLAhl/repo).

[CASE 4] compact-context with empty session_id input + empty live.worktree_root
Command result:
CASE4_RC=0
ALERT_ABSENT

Assessment:
- Guard blocks with session_id present, and also blocks empty session_id when binding metadata exists.
- If session_id is empty but session-map binding exists, guard now blocks (fail-closed).
- compact-context can still warn via [WORKTREE ALERT] only when expected worktree metadata exists.
- Therefore, known bypass is closed when binding metadata exists; drift risk remains only when both session-map and live worktree metadata are absent.
