### Expert β: Sidney Dekker

**Framework**: 실패로의 표류(drift into failure) — 복잡 시스템은 극적인 단일 실패가 아니라, 국소적으로 합리적인 결정들이 누적되면서 점진적으로 안전 경계 밖으로 밀려난다.
**Source**: *Drift into Failure* (Ashgate, 2011)
**Why this applies**: 30회 이상의 세션을 거치며 성장한 CWF 프로젝트에서, 이번 full-repo-refactor는 사실상 "누적된 미세 표류의 일괄 발견 및 교정" 세션이었다. ship 스킬의 한국어 하드코딩, 컨벤션 문서와 린트 규칙의 괴리, README 구조 불일치 — 이 모든 것이 각 세션에서 국소적으로 합리적인 선택의 결과였다. CDM 분석이 각 결정의 구조와 근거를 해부했다면, 이 분석은 **그 결정들이 왜 그토록 오래 보이지 않았는가** — 즉, 표류의 메커니즘 자체를 다룬다.

---

#### 순간 1: Ship 스킬의 점진적 환경 고착 (CDM 3 위의 층위)

CDM 3은 ship 스킬에서 8개의 하드코딩 값을 발견하고 동적 패턴으로 전환한 결정을 분석했다. 나는 그 **이전**을 본다 — 왜 3개 이상의 세션(S3→S4.5→현재)에 걸쳐 이 하드코딩이 축적되었고, 왜 아무도 이를 문제로 인식하지 않았는가.

*Drift into Failure*의 핵심 메커니즘 중 하나는 "practical drift"다. Diane Vaughan이 챌린저호 사고 분석에서 처음 명명하고 내가 일반화한 이 개념은, 규범에서의 이탈이 반복적 성공을 통해 정상화되는 과정을 설명한다. Ship 스킬은 처음에 한국어 사용자를 위해 만들어졌다. `Language: Korean`은 그 시점에서 완벽히 합리적이었다. 다음 세션에서 `marketplace-v3` 브랜치가 추가됐다 — 현재 개발 브랜치이므로 합리적이다. PR 템플릿에 한국어 테이블 헤더가 들어갔다 — 이미 한국어 정책이 선언되어 있으니 일관된 선택이다.

여기서 표류의 본질이 드러난다: **각 결정은 이전 결정과 일관되었기 때문에 합리적으로 보였다.** 하지만 이전 결정 자체가 이미 컨벤션(다른 12개 스킬의 "user's language" 패턴)에서 이탈한 상태였다. 국소적 일관성이 전역적 비일관성을 은폐한 것이다. 이것이 정확히 *Drift into Failure*에서 말하는 "the banality of accidents" — 실패는 극적 순간이 아니라 평범한 일상적 합리성 속에서 자란다.

**CDM과의 차이**: CDM 3은 "무엇을 결정했고 왜 그 옵션이 최선이었는가"를 해부했다. 내 분석은 "왜 이 결정이 필요한 지점까지 도달했는가" — 즉, 결정 시점(point of decision)이 아니라 표류 궤적(trajectory of drift)을 다룬다. 결정 자체는 올바랐다. 문제는 결정의 필요성이 세 세션이나 지연되었다는 점이다.

**내가 다르게 했을 것**: 스킬 생성 시점에 "portability gate"를 두었을 것이다. 새 스킬이 생성될 때 Language 선언이 기존 패턴 풀(pool)과 일치하는지 자동 검증하는 린트 규칙이다. CORCA003이 frontmatter 형식을 강제하는 것처럼, Language 선언의 패턴 일치를 강제하는 CORCA-LANG 같은 규칙이 있었다면 S3 시점에서 포착되었을 것이다. 중요한 점은: 이것은 "실수를 예방"하는 것이 아니다. 당시의 한국어 고정이 실수가 아니었기 때문이다. 이것은 **국소적 합리성이 전역적 비일관성으로 전환되는 순간을 가시화**하는 것이다.

---

#### 순간 2: 컨벤션 문서와 린트 규칙의 침묵하는 괴리 (CDM 1 위의 층위)

CDM 1에서 가장 인상적인 발견은 CORCA003 린트 규칙이 single-line 형식을 강제하는 동안 `skill-conventions.md`가 multi-line `|` 형식을 명시적으로 요구하고 있었다는 것이다. 그리고 이 두 규칙이 **동시에 존재하면서도 충돌이 감지되지 않았다.**

*Drift into Failure*에서 이 현상을 설명하는 개념은 "decrementalism"이다. 시스템은 한 번에 크게 실패하지 않는다. 작은 증분적 변경이 누적되면서, 각 변경은 이전 상태에서 너무나 미세한 차이여서 경보를 울리지 않는다. 컨벤션 문서가 먼저 작성되었다. 린트 규칙이 나중에 추가되었다 — 아마도 "실제 코드가 이미 single-line이니 그것을 강제하자"는 실용적 판단으로. 문서 업데이트는 잊혔거나, "나중에 하자"고 미뤄졌다. 13개 스킬이 이미 single-line이었으므로, 문서와의 불일치는 실제 운영에서 마찰을 일으키지 않았다 — 불일치가 마찰을 일으키지 않는 한, 불일치는 보이지 않는다.

이것이 표류의 위험한 속성이다: **괴리가 결과를 낳지 않는 동안, 괴리 자체가 정상 상태로 편입된다.** 이 세션의 Holistic Convention 분석이 13개 스킬 전부를 동시에 조망했을 때 비로소 괴리가 드러났다. 개별 스킬을 순차적으로 보았다면 — 각 스킬의 frontmatter가 "잘 작동하고 있으므로" — 발견하지 못했을 것이다.

**CDM과의 차이**: CDM 1은 충돌 발견 후 "린트가 SSOT"라는 의사결정의 합리성을 입증했다. 내 분석은 그 의사결정이 애초에 불필요했어야 했다는 점을 지적한다 — 린트 규칙 추가 시점에 컨벤션 문서가 동기화되었다면. 결정의 품질이 아니라 결정의 **필요 조건이 존재한 시스템 상태**가 분석 대상이다.

**내가 다르게 했을 것**: 린트 규칙을 추가하거나 변경할 때 "convention doc sync check"를 강제했을 것이다. 구체적으로, CORCA 린트 규칙 파일과 `skill-conventions.md` 사이의 교차 참조(cross-reference) 주석을 양쪽에 추가한다. 예: `# Corresponds to skill-conventions.md §Frontmatter`와 `<!-- Enforced by CORCA003 -->`. 이렇게 하면 한쪽을 수정할 때 다른 쪽이 어디인지 즉시 보인다. 자동화 이전에, 연결(link)만으로도 침묵하는 괴리를 발화하는(speaking) 괴리로 바꿀 수 있다.

---

#### 순간 3: README 구조 불일치의 세션간 축적 (CDM 4 위의 층위)

README.ko.md(SSOT)에 "설계 의도" + "무엇을 하는가" 서브섹션이 존재하는데 README.md에는 없었다. 이 구조 차이가 여러 세션에 걸쳐 성장했다 — 각 세션에서 새 스킬을 추가할 때 SSOT의 구조를 영문에 미러링하지 않고 "내용만" 반영했다.

이것은 *Drift into Failure*가 설명하는 "erosion of safety margins"의 문서 버전이다. SSOT 선언은 안전 마진이다 — "이 문서의 구조를 따르면 동기화가 보장된다"는 약속. 하지만 매 세션마다 내용만 동기화하고 구조는 동기화하지 않을 때, SSOT의 "안전 마진"은 조금씩 잠식된다. 각 세션에서 "이번에는 내용만 맞추면 되니까"라는 판단은 국소적으로 합리적이었다. 구조 차이가 즉각적 문제를 일으키지 않았기 때문이다. 하지만 13개 스킬이 모두 구조가 다른 상태에 도달했을 때, 이것은 더 이상 "약간의 차이"가 아니라 SSOT 원칙 자체의 유명무실화였다.

이 세션에서 잘한 점은 Docs Review가 이 축적된 표류를 한번에 포착하고, CDM 4 결정으로 13개 스킬 전부를 일괄 정렬한 것이다. 이것은 *Drift into Failure*의 관점에서 보기 드문 "reset to safe state" — 표류를 인지하고 한 번의 의도적 행동으로 되돌린 사례다. 대부분의 실패 사례에서 이런 리셋은 일어나지 않는다. 여기서 리셋이 가능했던 이유는 holistic refactor 모드가 전체 시스템을 동시에 조망하도록 설계되어 있었기 때문이다.

---

#### 세션 횡단 관찰: Holistic Analysis가 Anti-Drift 메커니즘인 이유

세 가지 순간 모두에서 공통된 패턴이 있다: **표류는 개별 스킬/세션 단위의 시야에서는 보이지 않았고, 전체를 동시에 조망하는 분석에서만 드러났다.** Ship의 하드코딩은 다른 12개 스킬과 비교할 때만 "이상"이 된다. 린트와 문서의 괴리는 "13개 스킬 전부가 린트를 따르고 있다"는 사실을 알 때만 문서 쪽이 잘못임이 명확해진다. README 구조 차이는 13개 스킬을 동시에 조망할 때만 체계적 패턴으로 인식된다.

이것은 이 프로젝트가 holistic refactor 모드를 구축한 것이 단순한 편의 기능이 아니라 **구조적 표류 감지 장치**임을 의미한다. *Drift into Failure*의 관점에서, 이 세션에서 가장 가치 있었던 것은 개별 수정들이 아니라 "전체 시스템을 동시에 볼 수 있는 역량 자체를 실행한 것"이다. 토큰 압력이 일괄 처리를 촉진했다는 CDM의 관찰(횡단 관찰 #4)도 같은 맥락이다 — 자원 제약이 역설적으로 전체-동시 조망을 강제하여, 표류 감지 효과를 높였다.

---

**Recommendations**:

1. **정기적 holistic scan 주기를 명시적으로 설정하라.** 이번 세션처럼 대규모 리팩터링이 아니더라도, N 세션마다(예: 5세션 또는 주요 기능 추가 후) `cwf:refactor --holistic` convention 축의 약식 스캔을 실행한다. 표류는 누적 속도가 느리기 때문에 "문제가 보일 때" 실행하면 이미 늦다. *Drift into Failure*가 반복적으로 강조하듯, 사고는 "이상 징후가 아닌 정상 운영" 중에 발생한다. 정기 스캔은 정상 상태에서의 경계 침식을 포착하는 유일한 메커니즘이다. 구체적으로, `cwf-state.yaml`에 `last_holistic_scan` 타임스탬프와 `holistic_scan_interval` 값을 추가하고, `cwf:refactor`나 `cwf:setup` 시작 시 경과 세션 수가 임계치를 넘으면 경고를 표시한다.

2. **자동화 규칙(린트, 훅)을 추가/변경할 때 "convention doc sync" 체크를 의무화하라.** CORCA 규칙 파일에 `# Convention doc: skill-conventions.md §{section}` 형태의 역참조 주석을 추가하고, 컨벤션 문서 해당 섹션에 `<!-- Gate: CORCA00N -->` 마커를 삽입한다. 이 교차 참조가 있으면, 한쪽을 수정할 때 `grep`으로 다른 쪽의 위치를 즉시 찾을 수 있다. 린트와 문서의 "침묵하는 괴리"가 구조적으로 불가능해진다. 이것은 규칙 자체의 품질 문제가 아니라 **규칙들 사이의 관계가 가시적이지 않은 문제**를 해결한다 — *Drift into Failure*에서 내가 "unruly technology"라 부르는 것, 즉 구성 요소들이 각자 잘 작동하면서도 전체로서는 예측 불가능하게 행동하는 상태를 방지하는 최소한의 장치다.

<!-- AGENT_COMPLETE -->
