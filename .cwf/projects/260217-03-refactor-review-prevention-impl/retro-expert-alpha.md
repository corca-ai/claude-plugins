### Expert α: Nancy Leveson

**Framework**: STAMP/STPA (Systems-Theoretic Accident Model and Processes) — modeling accidents as resulting from inadequate control rather than component failure, analyzing hierarchical control structures, identifying unsafe control actions, and tracing causal factors to inadequate feedback, flawed mental models, and missing constraints.
**Source**: *Engineering a Safer World: Systems Thinking Applied to Safety* (MIT Press, 2011), roster-verified.
**Why this applies**: This session designed and implemented automated control mechanisms (hooks) to prevent a recurrence of an incident where an agent deleted a file with active runtime callers. STAMP treats such incidents not as "errors" but as inadequate enforcement of safety constraints within a control structure. The session's core work — building controllers (hooks), defining control actions (block/allow), establishing feedback channels (state files), and calibrating fail-closed/fail-open behavior — maps directly to STAMP's vocabulary.

---

#### Moment 1: The PostToolUse-to-PreToolUse Correction — Control Action Timing as a First Principle

The single most consequential event in this session was the plan review's identification and subsequent correction of Proposal A's hook timing. The previous agent (S260217-02) had implemented `check-deletion-safety.sh` as a **PostToolUse** hook. During plan review, I (as Expert α) identified this as UCA-1 "Provided too late": a post-action controller cannot prevent the action it monitors. The plan's own Decision Log #1 — "Command text is available before execution" — actually argued for PreToolUse but the plan contradicted itself by specifying PostToolUse. The synthesis verdict was "Revise," and the plan was corrected to PreToolUse before implementation proceeded.

This correction was not a minor detail. It was the difference between a **prevention barrier** and a **detection barrier**. In STAMP terms, a PreToolUse hook is a controller with a direct actuator path to the controlled process: exit 1 prevents the tool from executing. A PostToolUse hook is a sensor that fires after the process state has already transitioned — the file is already deleted; the hook can only report and advise rollback. The distinction is between a closed-loop control action (controller can influence the process before the hazardous state is reached) and an open-loop observation (controller observes the hazardous state after it exists).

What worked well here: the multi-reviewer, multi-framework review architecture caught this error with strong cross-reviewer consensus (4/6 reviewers flagged it as critical). The STAMP framing — "control action provided too late" — gave the finding a structural vocabulary that made the fix unambiguous. There was no debate about whether to move to PreToolUse; the control theory argument was dispositive. The CDM analysis records this correctly: the build-on-top strategy inherited the previous agent's PostToolUse choice, and the gap analysis caught it.

What the session's CDM does not fully articulate: the fact that the previous agent got this wrong reveals a **flawed mental model** about how Claude Code hooks enforce decisions. The previous agent's code used `exit 0` in `json_block()` — meaning even the blocking path *allowed* the action. This is not a coding mistake; it is a conceptual misunderstanding of the control mechanism. The exit code *is* the actuator. The JSON output is feedback to the operator (the agent), but the exit code is the control action to the runtime. In STAMP, when the controller's designer misunderstands the actuator mechanism, the resulting system has the form of a control structure but none of its substance. The session fixed both the timing (PostToolUse to PreToolUse) and the actuator (exit 0 to exit 1), but these are two manifestations of the same underlying problem: the previous agent lacked an accurate model of hook execution semantics.

**Recommendation from this moment**: Future hook development should start from an explicit control structure diagram: What is the controlled process? What is the control action? What is the actuator? What feedback does the controller receive? The PreToolUse/PostToolUse choice should be derived from this diagram — PreToolUse when the control action must prevent a state transition, PostToolUse when the control action is observational. This is not a guideline to memorize; it is a structural analysis that must be performed for each new hook. The session's lessons file records the exit code rule ("exit 1 = block, exit 0 = allow") but not the deeper principle about why PreToolUse is necessary for prevention. A hook design checklist grounded in the STAMP control structure would prevent this class of error structurally rather than relying on review to catch it.

---

#### Moment 2: The Fail-Closed/Fail-Open Asymmetry — Calibrating Control Actions to Consequence Severity

CDM-2 documents the deliberate asymmetry between `check-deletion-safety.sh` (fail-closed on all dependency failures) and `workflow-gate.sh` (fail-open on jq/state-file absence). The code review flagged this as an inconsistency (3/6 reviewers). The CDM correctly identifies consequence irreversibility as the design basis: deletion is irreversible, so the deletion hook blocks when its detection is impaired; workflow gate violations are recoverable process deviations, so the workflow hook allows when its detection is impaired rather than bricking the entire session.

From STAMP, this asymmetry is not merely defensible — it is the correct application of what I call the **safety constraint enforcement principle**: the stringency of enforcement must be proportional to the severity of the hazard and inversely proportional to the reversibility of the consequence. A controller that blocks all actions when it cannot verify safety is appropriate for irreversible hazards (file deletion). The same controller applied to process enforcement (workflow gates) would create a new hazard: total session paralysis whenever `jq` is missing or the state file is corrupt. In safety engineering, an overly aggressive safety mechanism that prevents all work is itself a hazard — it creates pressure to disable the mechanism entirely, which is far worse than a calibrated fail-open.

The session handled this well at the design level. What it did not do well was **documenting the asymmetry's rationale in the code itself**. The CDM analysis explains the reasoning. The retro explains it. But neither `check-deletion-safety.sh` nor `workflow-gate.sh` contains a comment explaining why their fail modes differ. Code review flagged it as an inconsistency because the code provides no local explanation. A future maintainer reading `workflow-gate.sh` in isolation will see `exit 0` on jq-missing and reasonably ask: "Shouldn't this fail closed like the deletion hook?" If the answer is only in retrospective documents, the asymmetry will erode over time — a maintainer will "fix" it to be consistent, not realizing the inconsistency is intentional. This is exactly how STAMP describes **control structure degradation**: the original designers' safety reasoning is not embedded in the artifact that implements it, so subsequent modifications drift away from the safety intent.

The code review's Expert β (Perrow) identified a related concern: the `remaining_gates` mechanism is derivable from the `phase` field, making it redundant mutable state that must be kept in sync. This is a valid coupling concern, but from STAMP it also represents a **feedback channel design choice**. The `phase` field tells you where you are; `remaining_gates` tells you what constraints are still active. These serve different control purposes. Phase is a process variable; remaining gates are active safety constraints. Deriving gates from phase would make the control structure simpler but would eliminate the ability to have non-standard gate configurations (e.g., skipping a gate with explicit override). The session's design preserves this flexibility at the cost of sync coupling. Whether this trade-off is correct depends on whether non-standard gate configurations are actually needed — a question the session did not explicitly resolve.

**Recommendation from this moment**: Embed the fail-mode rationale directly in each hook script as a structured header comment. A template like `# FAIL MODE: closed | Rationale: file deletion is irreversible; false-positive cost is retry, false-negative cost is data loss` and `# FAIL MODE: open (dependency failures only) | Rationale: blocking all prompts on jq-missing would paralyze session; gate violations are recoverable process deviations` would make the asymmetry self-documenting and resistant to well-intentioned "consistency fixes." This is a specific application of the STAMP principle that safety constraints must be visible at the point of enforcement, not only in external analysis documents.

---

#### Moment 3: Compaction-Driven Decision Loss — Inadequate Feedback Across Control Boundaries

CDM-4 describes how the user's decision to "proceed with 4/6 reviewers" was lost to context compaction, causing 3 redundant fallback retry attempts. The CDM correctly identifies this as a feedback channel failure: the decision existed in conversation context (volatile) but not in persistent state (durable). The retro recommends recording such decisions in compaction-immune storage.

From STAMP, this is a textbook case of **inadequate feedback in a hierarchical control structure**. The user (higher-level controller) issued a control action ("proceed with 4 reviews"). The agent (lower-level controller) received and acted on it. Then a system event (compaction) severed the feedback channel between the user's decision and the agent's subsequent behavior. The agent, having lost the feedback, reverted to its default behavior (retry external CLIs). The user then had to re-issue the same control action — but the agent's behavior in the interim (3 retry attempts) consumed resources and, more importantly, eroded the user's confidence that the agent maintains state correctly.

What makes this particularly interesting from a STAMP perspective is that the session was simultaneously *building* compaction-immune state mechanisms (Proposal E+G's `remaining_gates` in YAML) while *suffering from* the absence of such mechanisms for its own operational decisions. The `workflow-gate.sh` hook reads from persistent YAML precisely because conversation context is unreliable across compaction. Yet the session's own review orchestration stored a critical user decision only in conversation context. The irony is structural: the session understood the problem well enough to engineer a solution for pipeline enforcement but did not apply the same pattern to its own process.

The 5 Whys in the retro traces this to "decision_journal이 존재하지만 hook-level 의사결정까지 포함하지 않음" — the decision journal exists but does not cover hook-level decisions. But from STAMP, the deeper issue is not the journal's scope; it is the absence of a **feedback verification mechanism**. In a well-designed control structure, when a higher-level controller issues a command, the lower-level controller acknowledges receipt and the acknowledgment is verified. If the acknowledgment is lost (compaction), the system should detect the loss and re-query rather than silently reverting to default. The `state_version` field in `cwf-live-state.sh` is exactly this kind of mechanism — it detects stale state by comparing versions. A similar mechanism for user decisions (decision stored with a version, agent verifies the version is current before acting on default behavior) would close this feedback loop.

This moment also connects to the broader pattern across CWF sessions: compaction is not an exceptional event but a **normal operating condition** of long-running agent sessions. Any control action or decision that exists only in conversation context has a finite lifetime bounded by the compaction threshold. The session's own experience — multiple compactions during the pipeline — demonstrates that compaction is not edge-case but steady-state. STAMP would say: design the control structure for the normal operating envelope, which includes compaction. Any safety-relevant state that is not compaction-immune is not actually enforced; it is merely hoped for.

**Recommendation from this moment**: Extend the `cwf-live-state.sh` decision journal to automatically persist user decisions from `AskUserQuestion` responses, using the same `set` mechanism that persists pipeline state. When the agent recovers from compaction, the recovery protocol should read the decision journal and surface persisted decisions in the recovery context, rather than re-querying the user. This converts user decisions from volatile feedback (conversation context) to durable feedback (state file), matching the design pattern already proven by `remaining_gates`. The implementation is small — a `cwf-live-state.sh set . decision_journal[N]="proceed_with_4_reviewers"` call after the user responds — but the structural effect is large: it closes the feedback loop across compaction boundaries.

---

#### Cross-Cutting Observation: The Session as a Control Structure Design Exercise

Stepping back from individual moments, this session is remarkable in that it is explicitly a control structure design exercise — building automated controllers (hooks) that enforce safety constraints on a controlled process (agent behavior). The session applied many STAMP principles correctly, often without naming them: fail-closed for irreversible consequences, persistent state for compaction immunity, fast-exit paths to minimize controller overhead, detection boundary documentation. The plan review stage functioned as a design verification step that caught the most critical control structure error (PostToolUse timing). The code review stage identified latent conditions (duplicated parsers, fixed temp paths) that could degrade the control structure over time.

The areas where STAMP analysis reveals gaps are precisely the areas where the session's *implicit* control theory knowledge was not made *explicit*:

1. The fail-mode asymmetry is correct but not self-documented in the code.
2. The compaction-immune pattern is applied to pipeline state but not to operational decisions.
3. The control action semantics (exit code = actuator, JSON = feedback) are learned as a lesson but not formalized as a design constraint for future hooks.

The session's defense-in-depth architecture — 4 independent barrier layers with uncorrelated failure modes — is sound. James Reason's analysis (Expert α in the code review) confirms this from the Swiss cheese perspective. My STAMP analysis does not contradict it but adds a dimension: the barriers are not just passive layers with holes; they are active controllers with feedback loops, actuator mechanisms, and mental model dependencies. The quality of the defense depends not just on the independence of the barriers but on the accuracy of each controller's model of the system it controls and the adequacy of its feedback channels.

**Recommendations**:

1. **Create a hook design template grounded in STAMP control structure analysis.** Before implementing any new hook, the designer should fill in: (a) controlled process, (b) safety constraint being enforced, (c) control action (PreToolUse block vs PostToolUse observe vs UserPromptSubmit gate), (d) actuator mechanism (exit code semantics), (e) feedback channels (what the controller reads to make its decision), (f) fail mode and rationale (closed/open, with consequence severity justification), (g) detection boundary (what the controller can and cannot detect). This template would have prevented the PostToolUse timing error, the exit 0 actuator error, and the undocumented fail-mode asymmetry — all three of which stem from incomplete control structure analysis at design time.

2. **Treat compaction as a normal operating condition in the control structure, not an exceptional event.** Any state that influences controller behavior must be compaction-immune by default. This applies to pipeline state (already addressed by `remaining_gates`), user decisions (not yet addressed), and controller configuration (currently in `cwf-hooks-enabled.sh`, which is persistent). The decision journal gap exposed by CDM-4 should be closed by automatic persistence of user decisions at the point they are made, using the same `cwf-live-state.sh` infrastructure that the session already built.

<!-- AGENT_COMPLETE -->
