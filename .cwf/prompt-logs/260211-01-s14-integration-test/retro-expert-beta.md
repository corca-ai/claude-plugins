### Expert beta: Richard Cook

**Framework**: 복잡 시스템 실패의 본질에 대한 시스템 안전(Systems Safety) 분석 — 실패는 단일 원인이 아니라 다중 잠재 결함의 상호작용이며, 운영자(operator)가 표상의 선(line of representation) 위에서 끊임없이 시스템 모델을 구축·갱신하며 안전을 능동적으로 생산한다는 관점.

**Source**:
- Cook, R.I. (1998/2000). *How Complex Systems Fail*. Cognitive Technologies Laboratory, University of Chicago. Revision D (00.04.21). — 복잡 시스템 실패에 관한 18가지 원칙. (https://how.complexsystems.fail/)
- Cook, R.I. (2020). "Above the Line, Below the Line." *ACM Queue*, 17(6). doi:10.1145/3380774.3380777 — 표상의 선(line of representation) 모델.
- Cook, R.I. & Rasmussen, J. (2005). "'Going solid': a model of system dynamics and consequences for patient safety." *BMJ Quality & Safety*, 14(2):130-134. doi:10.1136/qshc.2003.009530 — 시스템이 여유 용량을 상실할 때 발생하는 동역학.

**Why this applies**: S14 세션은 복잡 시스템 실패의 전형적 패턴을 보여준다. S33 프로토콜이 하나의 가시적 실패(404)를 수정했지만 더 깊은 비가시적 실패(JS 렌더링 불가)를 은폐했고, 자동화(에이전트)가 놓친 것을 운영자(사용자)가 발견했다. 이것은 Cook이 18가지 원칙에서 반복적으로 강조한 "잠재 결함의 항상적 존재"와 "운영자의 능동적 안전 생산"이 정확히 작동한 사례다.

---

#### 1. "사후 단일 근본 원인 귀속은 근본적으로 오류다" — 원칙 #7과 S33 프로토콜의 함정

Cook의 원칙 #7은 이렇게 말한다: *"사고의 고립된 '원인'이란 없다. 사고에는 복수의 기여 요인이 존재한다."* (*How Complex Systems Fail*, 원칙 7) 또한 원칙 #8은 사후 지식이 사건의 현저성을 왜곡한다(hindsight bias)고 경고한다.

S33에서 Web Research의 실패를 분석할 때, "404 에러"가 가장 가시적인 실패 모드였다. URL 구성 규칙을 수정하는 프로토콜이 만들어졌고, 404가 사라졌다. 여기까지는 성공적인 사후 분석처럼 보인다. 그러나 이것이 바로 Cook이 경고한 함정이다 — 가장 눈에 띄는 실패 모드에 원인을 귀속시키고, 나머지 잠재 결함을 방치하는 것.

S14의 경험적 리플레이가 드러낸 실상: 404는 0건으로 줄었지만, 전체 성공률은 9%였다. 실패의 실제 구성은 JS 렌더링 불가(45%), 403 차단(18%), 리다이렉트 체인(27%)이었다. 404 수정은 전체 실패 공간의 한 조각만 처리한 것이었다. Cook의 원칙 #4가 정확히 이 상황을 서술한다: *"복잡 시스템은 불가피하게 다수의 잠재 결함을 포함하며, 이들은 개별적으로는 사고를 일으키지 않지만 집단적으로 취약성을 만든다."*

더 중요한 것은 원칙 #14다: *"새로운 기술이 익숙한 문제를 제거하면, 종종 전례 없는 새로운 실패 모드를 도입한다."* S33 프로토콜은 404라는 "익숙한 문제"를 제거했지만, 그 과정에서 WebFetch의 JS 렌더링 한계라는 더 근본적인 실패 모드를 은폐했다. 404가 사라지자 "프로토콜이 문제를 해결했다"는 인상이 형성되었고, 에이전트가 이론적 분석만으로 "유효하다"고 판단하려 한 것은 이 은폐 효과의 직접적 결과다.

#### 2. 표상의 선(Line of Representation) — 에이전트가 못 본 것, 사용자가 본 것

Cook의 "Above the Line, Below the Line" (ACM Queue, 2020)은 소프트웨어 시스템 운영에서 핵심적인 인지적 구조를 묘사한다. **표상의 선 위**에는 사람, 조직, 인간의 프로세스가 있고, **선 아래**에는 소프트웨어 아티팩트와 인프라가 있다. 운영자는 시스템을 직접 관찰하거나 조작할 수 없으며, 오직 **표상(representation)**을 통해서만 상호작용한다. Cook은 이렇게 쓴다: *"선 위에서 일하는 사람들은 선 아래에 있는 것의 모델을 끊임없이 구축하고 갱신한다."*

S14에서 에이전트는 표상의 선 위의 존재다. 에이전트가 볼 수 있는 것은 WebFetch의 반환 결과뿐이고, WebFetch 내부에서 무슨 일이 일어나는지 — HTTP GET만 수행하는지, JS를 실행하는지 — 에 대한 **표상이 없다**. 에이전트의 WebFetch에 대한 정신 모델(mental model)은 "URL을 넣으면 콘텐츠가 나오는 도구"였다. 실패할 때 에이전트는 자신의 아키텍처(sub-agent vs agent team)를 의심했지, 도구 자체의 구조적 한계를 의심하지 않았다. 이것은 Cook이 강조한 **표상의 선 아래 작동 원리에 대한 불완전한 모델**이 잘못된 진단을 낳는 전형적 사례다.

반면 사용자는 다른 위치에 서 있었다. 사용자는 "모던 웹사이트는 대부분 JS로 렌더링된다"는 도메인 지식과 "WebFetch가 HTTP GET만 하는 도구일 수 있다"는 도구 수준의 인식을 가지고 있었다. 더 중요한 것은, 사용자가 **경험적 리플레이를 통해 표상을 갱신하려 했다**는 것이다. 이론적 추론이 아니라 실제 데이터를 통해 선 아래의 실체를 파악하려 한 것이다. Cook의 프레임워크에서 이것은 "운영자가 시스템 모델을 능동적으로 갱신하는" 행위이며, 원칙 #17이 말하는 **안전의 능동적 생산(continuous safety creation)**에 해당한다.

에이전트가 4턴에 걸쳐 아키텍처 논쟁에 빠진 것은, Cook의 관점에서 보면, 표상의 선 아래에 대한 잘못된 모델에 기반한 불필요한 의사결정이었다. 올바른 표상이 없으면, 올바른 처방도 불가능하다.

#### 3. "Going Solid" — compact-context.sh의 경고 신호

Cook과 Rasmussen (2005)의 "Going Solid" 모델은 시스템이 여유 용량을 상실할 때 느슨한 결합(loose coupling)에서 긴밀한 결합(tight coupling)으로 전환되며, 그 순간 교란의 영향이 급격히 확대된다고 서술한다. 원래 원자력 발전소의 보일러가 액체로 완전히 채워져 "solid 상태"가 되면 운영 특성이 급변하는 현상에서 온 용어다.

compact-context.sh는 이 세션에서 "going solid"의 초기 징후를 보여준다. 손으로 작성한 YAML 파서가 cwf-state.yaml의 새 필드(`decisions`)를 처리하지 못해 데이터가 다른 필드(`key_files`)로 누출되었다. 인용 부호 처리의 불일치로 경로 조회가 조용히 실패했다. 현재는 이것들이 "버그 2개"에 불과하지만, Cook/Rasmussen의 관점에서 이것은 **시스템이 여유를 상실해가는 신호**다.

CWF v3가 24세션(S0-S33)에 걸쳐 20개의 아키텍처 결정을 축적하면서, cwf-state.yaml의 복잡도는 계속 증가하고 있다. 손으로 작성한 파서는 처음에는 느슨하게 결합되어 있었다 — 필드가 적을 때는 각 필드 핸들러가 독립적이었다. 그러나 필드가 늘어나면서 파서의 내부 상태(`current_list`)가 여러 필드 핸들러 사이의 암묵적 의존성을 만들기 시작했다. 이것이 바로 "going solid"의 초기 단계다: 구성요소 간의 결합이 증가하면서, 한 곳의 변경(새 필드 추가)이 예상치 못한 곳(다른 필드의 파싱)에 영향을 미치기 시작한다.

Cook은 이 상태가 반드시 즉각적 재앙을 의미하지는 않지만, **사고의 기회가 증가하는 조건**을 만든다고 강조한다. compact-context.sh의 현재 상태는 아직 관리 가능하지만, CWF가 더 많은 세션과 필드를 축적할수록, 이 손으로 작성한 파서가 "going solid" 상태에 도달할 위험이 있다.

---

#### 전체 평가: 복잡 시스템은 "깨진 상태"로 운행된다

Cook의 원칙 #5는 이렇게 말한다: *"복잡 시스템은 '깨진 시스템(broken systems)'으로 운행하는 경향이 있다. 즉, 성능이 정상적으로 작동하는 동안에도 항상 '결함'이 존재한다."* S14 세션은 이 원칙의 실증이다. WebFetch는 "작동하는 도구"로 분류되어 있었지만, 실제로는 모던 웹의 91%를 읽지 못하는 "깨진 도구"였다. 시스템은 이 결함을 안고 운행하고 있었고, S33의 404 수정이 이 사실을 더욱 불투명하게 만들었다.

이 세션에서 가장 가치 있었던 순간은 사용자가 에이전트의 이론적 판단을 거부하고 경험적 리플레이를 강제한 것이다. Cook의 원칙 #9, #11, #12가 함께 작동한 순간이다: 운영자가 생산과 안전의 이중 역할을 수행하고(#9), 최종적으로 모든 모호성을 해결하며(#11), 시스템 운영을 순간순간 수정하는(#12) — 이것이 바로 **sharp end에서의 인간 적응성**이다.

2-tier fetch 아키텍처(WebFetch 시도 → 실패 시 agent-browser 폴백)의 도입은 Cook의 관점에서 올바른 방향이다. 이것은 원칙 #2가 말하는 **다층 방어(multilayered defenses)**에 해당한다. 그러나 Cook은 방어 층 추가가 새로운 복잡성을 만들어낸다고도 경고한다. 2-tier 시스템은 "WebFetch 성공/실패를 어떻게 판정할 것인가"라는 새로운 의사결정 지점을 도입하며, 이 판정이 잘못되면 불필요한 agent-browser 호출(성능 저하) 또는 필요한 호출 누락(같은 실패)이 발생한다.

**Recommendations**:

1. **표상의 선 아래 도구에 대한 "운영 모델 문서(operational model document)"를 만들어라.** 각 도구(WebFetch, agent-browser, search.sh 등)가 실제로 무엇을 하고 무엇을 못 하는지를 명시하는 짧은 참조 문서가 필요하다. Cook의 "line of representation" 모델에서, 운영자의 정신 모델이 정확할수록 올바른 의사결정이 가능하다. S14에서 에이전트가 "WebFetch = HTTP GET only, no JS execution"이라는 사실을 사전에 알았다면, 아키텍처 논쟁 4턴이 1턴으로 줄었을 것이다. 이것은 도구별 `LIMITATIONS.md`나 SKILL.md 내 `## Known Limitations` 섹션으로 구현할 수 있다.

2. **compact-context.sh의 "going solid" 징후에 대응하여, 파서를 `yq` 같은 표준 도구로 교체하거나, 최소한 새 필드 추가 시 자동 검증하는 테스트를 도입하라.** Cook/Rasmussen의 "going solid" 모델이 보여주듯, 시스템이 여유를 잃어가는 초기에 대응하는 것이 결정적이다. 보일러가 완전히 liquid로 채워진 후에 대응하면 이미 운영 특성이 급변한 후다. 현재의 손으로 작성한 파서는 기능적으로 작동하지만, cwf-state.yaml에 필드가 추가될 때마다 "파서도 업데이트해야 한다"는 암묵적 결합이 존재한다. 이 결합을 명시화(테스트)하거나 제거(표준 파서)해야 한다.

<!-- AGENT_COMPLETE -->
