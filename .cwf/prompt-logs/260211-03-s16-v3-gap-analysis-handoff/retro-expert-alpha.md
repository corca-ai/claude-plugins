### Expert alpha: Charles Perrow

**Framework**: 정상 사고 이론 (Normal Accident Theory) — 상호작용적 복잡성(interactive complexity)과 밀결합(tight coupling)이라는 두 차원으로 시스템 실패의 불가피성과 분류를 분석하는 프레임워크
**Source**: *Normal Accidents: Living with High-Risk Technologies* (Basic Books, 1984; Princeton University Press 개정판, 1999)
**Why this applies**: S16 세션의 핵심 사건 — 다중 모델 오케스트레이션에서 Gemini CLI의 도구 해석 실패와 이에 대한 오류 분류 체계 확장 — 은 정확히 Perrow가 분석하는 영역이다. 이질적인 구성 요소(Claude, Gemini, Codex)가 밀결합된 파이프라인에서 예상치 못한 상호작용으로 발생하는 실패, 그리고 그 실패를 사후에 분류하는 체계의 설계 문제.

---

**CDM 2 분석: TOOL_ERROR 범주 생성 — 선형 상호작용과 복잡 상호작용의 구분**

*Normal Accidents*에서 나는 시스템 상호작용을 두 가지로 구분한다: **선형 상호작용**(linear interaction)과 **복잡 상호작용**(complex/interactive complexity). 선형 상호작용은 예상된 순서로 일어나며, 실패 시 원인-결과 경로가 명확하다. 복잡 상호작용은 예상치 못한 경로로 구성 요소들이 영향을 주고받으며, 실패 원인이 운영자에게 즉시 투명하지 않다.

S16에서 Gemini CLI의 실패는 표면적으로 "타임아웃"이라는 선형적 증상을 보였지만, 실제 원인은 복잡 상호작용이었다. `cwf:review` 스킬이 Gemini CLI에 작업을 디스패치할 때, 암묵적으로 가정한 것은 "Gemini CLI는 셸 명령을 실행할 수 있다"였다. 그러나 `-o text` 모드에서 Gemini의 도구 세트는 인터랙티브 모드와 다르다 — `run_shell_command`가 존재하지 않는다. 이것은 내가 *Normal Accidents* 6장에서 기술한 전형적인 **공유 자원의 비가시적 상태 변화**다: 하나의 구성 요소(Gemini CLI)가 호출 맥락(-o text vs. interactive)에 따라 내부 상태(사용 가능한 도구 목록)를 변경하지만, 이 상태 변화가 호출자(cwf:review)에게 불투명하다.

기존 오류 분류 체계(CAPACITY/INTERNAL/AUTH)가 이 실패를 포착하지 못한 것은 분류 체계 자체가 **선형 상호작용만을 가정**했기 때문이다. CAPACITY는 "자원이 소진되었다"(선형적 원인-결과), INTERNAL은 "제공자 내부 오류"(단일 구성 요소 장애), AUTH는 "인증 실패"(단일 관문 실패) — 모두 실패 원인이 단일 구성 요소 내에서 발생하고 그 인과 경로가 명확한 선형적 실패 모드다. 그러나 TOOL_ERROR는 **두 구성 요소 사이의 인터페이스**에서 발생한다: 호출자의 도구 가정과 피호출자의 실제 도구 목록 사이의 불일치. 이것은 구성 요소 실패가 아니라 **상호작용 실패**다.

내 프레임워크에서 보면, TOOL_ERROR를 별도 범주로 생성한 것은 단순히 "복구 전략이 다르기 때문"(CDM 분석의 결론)이 아니라, 더 근본적으로 **실패가 발생하는 시스템 층위가 다르기 때문**이다. CAPACITY/INTERNAL/AUTH는 구성 요소 내부 실패(component failure)인 반면, TOOL_ERROR는 구성 요소 간 상호작용 실패(interaction failure)다. 이 구분은 단순한 분류학적 정리가 아니라, 향후 어떤 종류의 실패가 추가될지를 예측하는 데 구조적 가치를 갖는다. 다중 모델 오케스트레이션 시스템이 성숙해질수록, 구성 요소 내부 실패보다 상호작용 실패가 지배적이 될 것이다 — 이것이 바로 내가 "정상 사고"라고 부른 것의 본질이다.

**CDM 1 분석: 전문가 쌍 선택 — 시스템이 자기 자신의 결함을 리뷰하는 재귀적 구조**

CDM 분석의 메타 관찰 — "Leveson의 STPA가 리뷰 대상(S17 handoff)에서 발견한 제어 구조 결함이 리뷰 시스템 자체(cwf:review의 Gemini 디스패치)에도 동일하게 존재했다" — 은 *Normal Accidents*에서 내가 가장 우려한 패턴과 정확히 일치한다. 내가 Three Mile Island 사고를 분석하면서 발견한 것은, **안전 시스템 자체가 그것이 감시하는 시스템과 동일한 복잡성 특성을 공유할 때, 안전 시스템은 자신이 탐지해야 할 실패 모드에 자체적으로 취약해진다**는 것이었다 (*Normal Accidents*, 4장).

S16에서 `cwf:review`는 S17 handoff 문서의 "open-loop 제어" 결함을 리뷰하는 도구였다. 그런데 cwf:review 자체가 Gemini CLI에 대해 open-loop 제어를 수행하고 있었다 — 작업을 디스패치하지만 도구 가용성에 대한 피드백 루프가 없었다. 이것은 안전 시스템이 그것이 감시하는 바로 그 결함 클래스를 공유하는 경우다. Perrow의 용어로, 이것은 **공통 모드 실패**(common-mode failure)다: 리뷰 대상과 리뷰 도구가 동일한 설계 결함을 공유하므로, 리뷰가 해당 결함을 발견하더라도 리뷰 도구 자체의 결함은 리뷰되지 않는다.

이 재귀적 문제의 해결은 내 프레임워크에서는 명확하다: **리뷰 시스템과 피리뷰 시스템은 가능한 한 결합 특성이 달라야 한다.** 즉, cwf:review의 외부 CLI 디스패치 메커니즘이 피리뷰 시스템(S17 handoff의 다중 페이즈 파이프라인)과 동일한 밀결합 패턴을 따르지 않도록 설계해야 한다. 구체적으로, 리뷰 도구의 외부 CLI 호출에는 사전 가용성 확인(pre-flight capability check)이라는 **독립적 피드백 채널**이 있어야 하며, 이 채널은 리뷰 대상의 제어 구조와 상이한 경로를 사용해야 한다.

**CDM 3 분석: 밀결합 시스템에서의 "발견 시점 수정" — 버퍼의 유무**

내 프레임워크에서 밀결합(tight coupling)의 핵심 특성은 **버퍼(slack)의 부재**다. 밀결합 시스템에서는 한 구성 요소의 상태 변화가 즉시 다른 구성 요소에 전파되며, 중간에 완충 영역이 없다. 반대로 소결합(loose coupling) 시스템에서는 버퍼, 재고, 대기열 등이 존재하여 한 구성 요소의 변화가 즉시 전파되지 않는다.

S16에서 "세션 중 즉시 수정 vs. 백로그 등록" 결정은 이 밀결합/소결합 구분의 관점에서 재해석할 수 있다. `lessons.md`는 소결합을 위한 **버퍼**다 — 발견된 문제를 즉시 수정하지 않고 중간 저장소에 놓아, 수정 작업이 현재 세션의 주요 작업 흐름과 결합되지 않도록 한다. 반면, 세션 중 즉시 수정은 진단-수정-배포를 하나의 밀결합 흐름으로 만든다.

CDM 분석이 제시한 세 가지 전제 조건(진단 완료, 원자적 범위, 사용자 관여)은 내 프레임워크의 언어로 번역하면 **밀결합을 안전하게 허용하는 조건들**이다. 진단이 완료되었다는 것은 상호작용의 복잡성이 해소되었다(실패 모드가 이해되었다)는 의미이고, 원자적 범위라는 것은 수정이 시스템의 다른 부분과 예상치 못한 상호작용을 일으키지 않는다는 의미이며, 사용자 관여는 독립적 관찰자에 의한 확인이 있다는 의미다. 이 세 조건이 밀결합의 위험(예상치 못한 전파, 비가시적 상호작용, 운영자 모델과 실제 상태의 괴리)을 각각 완화한다.

다만, 내가 우려하는 것은 이 세 조건의 **자기 평가 문제**다. *Normal Accidents*에서 반복적으로 관찰한 것은, 운영자가 "상황을 완전히 이해했다"고 믿는 바로 그 순간에 이해하지 못한 상호작용이 존재했다는 것이다. "진단 완료"라는 판단 자체가 운영자의 인지 모델에 의존하며, 그 모델이 불완전할 수 있다. S16에서는 수정 범위가 진정으로 원자적이었기 때문에 이 위험이 실현되지 않았지만, 이 패턴이 정례화되면 "진단 완료"의 기준이 점차 완화될 위험이 있다.

**Recommendations**:
1. **오류 분류 체계를 "구성 요소 실패"와 "상호작용 실패"의 두 층위로 재구조화하라.** 현재 CAPACITY/INTERNAL/AUTH는 모두 구성 요소 내부 실패이고, TOOL_ERROR는 상호작용 실패다. 이 구분을 명시적으로 만들면, 다음에 새로운 실패 모드가 발생했을 때 "이것은 어떤 구성 요소가 고장난 것인가, 아니면 구성 요소 간 인터페이스에서 발생한 것인가?"라는 첫 번째 질문이 분류를 안내한다. 다중 모델 오케스트레이션 시스템이 확장되면 상호작용 실패(모델 간 프로토콜 불일치, 도구 가용성 차이, 출력 형식 비호환 등)가 지배적 실패 모드가 될 것이며, 이를 위한 분류 공간을 사전에 확보해야 한다. 이것은 *Normal Accidents* 3장에서 내가 "상호작용 매트릭스"(interaction matrix)라고 부른 것의 오류 분류 체계 버전이다.
2. **cwf:review의 외부 CLI 디스패치에 "독립 채널 검증" 원칙을 적용하라.** 리뷰 도구가 피리뷰 시스템과 동일한 제어 결함을 공유하는 공통 모드 실패를 방지하려면, 외부 CLI 호출 전에 해당 CLI의 도구 가용성을 검증하는 경로가 작업 디스패치 경로와 **독립적**이어야 한다. 단순히 사전 검증을 추가하는 것이 아니라, 검증 메커니즘이 디스패치 메커니즘과 동일한 실패 모드를 공유하지 않도록 설계해야 한다. 예를 들어, Gemini CLI에 작업을 보내기 전에 `gemini --list-tools -o text` 같은 별도 명령으로 도구 목록을 확인하되, 이 확인 자체가 동일한 120초 타임아웃에 걸리지 않도록 독립적인 타임아웃과 폴백 경로를 가져야 한다.

<!-- AGENT_COMPLETE -->
