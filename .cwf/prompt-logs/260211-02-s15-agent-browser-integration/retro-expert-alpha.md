### Expert alpha: Martin Fowler

**Framework**: 리팩터링 패턴, 지식 중복 제거(Rule of Three), 공유 추상화, 진화적 설계
**Source**: *Refactoring: Improving the Design of Existing Code* 2nd ed. (2018); "Is Design Dead?" (martinfowler.com/articles/designDead.html); "BeckDesignRules" (martinfowler.com/bliki/BeckDesignRules.html)
**Why this applies**: S15 세션의 핵심 결정은 인라인 규칙을 공유 프로토콜 참조로 교체하는 것이었다. 이는 정확히 중복 제거와 공유 추상화 추출이라는 리팩터링의 근본 영역에 해당한다.

---

**CDM 1 분석: 인라인 규칙에서 공유 프로토콜 참조로의 전환**

이 결정은 리팩터링 카탈로그에서 가장 근본적인 패턴 중 하나인 **Extract Function** (이전 명칭: Extract Method)의 구조적 확장이다. 7개의 서브 에이전트가 각자 웹 리서치 규칙을 인라인으로 가지고 있었다는 것은 전형적인 **Duplicated Code** 코드 스멜이다. *Refactoring* 2판에서 중복 코드는 가장 먼저 다루는 코드 스멜이며, 그 이유는 명확하다: 중복된 지식은 하나만 변경되고 나머지는 방치될 때 드리프트를 일으킨다. S15에서 정확히 이 현상이 발생했다 -- agent-browser가 추가되었지만 인라인 규칙들은 여전히 WebFetch만 알고 있었다. 드리프트가 이미 **관찰 가능한 증거**로 존재했다는 점이 결정적이다. 드리프트 증거는 인라인 접근 방식이 유지 불가능하다는 것을 실증하며, 이 시점에서 공유 추상화(agent-patterns.md)로의 추출은 단순한 개선이 아니라 **필수적 리팩터링**이었다.

Kent Beck의 Simple Design 규칙에서 "No Duplication"을 설명하면서 내가 쓴 바와 같이, 이 규칙은 "perhaps the most powerfully subtle of these rules"이다. 중복 제거 과정 자체가 좋은 설계를 이끌어낸다. S15에서 agent-patterns.md의 Web Research Protocol 섹션이 바로 그 결과물이다 -- 중복을 제거하는 과정에서 2-tier fetch 전략(WebFetch 우선, agent-browser 폴백)이라는 명확한 설계가 자연스럽게 도출되었다.

**CDM 2 분석: 7개 전체 에이전트 업데이트 vs 실패한 2개만 수정**

여기서 "Rule of Three" (혹은 "Three Strikes and You Refactor")의 **역방향 적용**이 흥미롭다. 원래 Rule of Three는 "세 번째 중복을 볼 때 추상화하라"는 것이다. 그런데 S15에서는 이미 공유 추상화(agent-patterns.md 프로토콜)를 만든 상태였다. 이 시점에서 질문은 "추상화할 것인가?"가 아니라 "추상화를 어디까지 적용할 것인가?"로 바뀐다. CDM 2의 결정 -- 실패한 2개뿐 아니라 웹 리서치를 수행하는 7개 전체 에이전트에 프로토콜 참조를 적용한 것 -- 은 올바르다. *Refactoring* 2판의 **Move Statements into Function** 패턴과 일맥상통한다: 동일한 맥락에서 동일한 동작을 해야 하는 코드는 한 곳으로 모아야 한다. "저빈도 에이전트는 나중에"라고 미루는 것은 **Shotgun Surgery** 스멜을 방치하는 것이다. 변경 비용이 낮을 때(단순한 참조 교체) 전체 카테고리에 일괄 적용하는 것은 진화적 설계의 핵심 원칙인 "비용이 낮을 때 리팩터링하라"와 정확히 일치한다.

**CDM 3 분석: 병렬 충돌 시 안전한 커밋 우선**

"Is Design Dead?"에서 나는 진화적 설계가 작동하려면 **변경 비용 곡선을 평탄화**해야 한다고 주장했다. setup/SKILL.md가 병렬 에이전트에 의해 되돌려졌을 때, 재편집 대신 해당 파일 없이 커밋하는 결정은 이 원칙의 실전 적용이다. 완벽한 커밋을 추구하면서 충돌 해결에 시간을 쓰는 것은 변경 비용을 높인다. 반면 "지금 안전하게 커밋하고, 다음에 SKILL.md를 별도로 수정한다"는 접근은 변경 비용 곡선을 평탄하게 유지한다. 각 커밋은 작고, 행동을 보존하며, 되돌리기 쉬워야 한다 -- *Refactoring*에서 말하는 "작은 행동-보존 변환의 연속"과 동일한 철학이다.

다만 한 가지 지적할 점이 있다: 병렬 에이전트 간 파일 수준 조율 부재는 구조적 문제다. 이것은 코드 중복과 유사한 **지식 중복** 문제다 -- 두 에이전트가 같은 파일을 "소유"한다고 각각 믿고 있었다. 이 문제에 대한 해결책도 리팩터링적이어야 한다: 파일 소유권을 명시적 추상화로 추출하는 것이다 (예: 태스크 할당 시 파일 잠금 또는 배타적 소유권 선언).

**Recommendations**:
1. **파일 소유권 프로토콜을 agent-patterns.md에 추가하라.** 병렬 에이전트가 동시에 같은 파일을 수정하는 Shotgun Surgery 문제를 방지하려면, 태스크 생성 시 "이 태스크는 이 파일들을 수정한다"는 선언을 명시하고 다른 에이전트가 이를 존중하는 규약이 필요하다. 이는 중복된 암묵적 지식("누가 어떤 파일을 수정하는가")을 명시적 추상화로 추출하는 것이다.
2. **인라인 규칙이 아직 남아있는 다른 영역을 체계적으로 탐지하라.** S15에서 웹 리서치 프로토콜의 드리프트는 이미 관찰되었기 때문에 수정되었지만, 아직 드리프트가 관찰되지 않은 다른 인라인 규칙들이 존재할 수 있다. *Refactoring*의 접근법은 "나쁜 냄새가 나면 리팩터링하라"이지만, 한 종류의 냄새를 발견했다면 같은 패턴의 냄새가 다른 곳에도 있을 가능성이 높다. `grep`으로 서브 에이전트 프롬프트 내 인라인 규칙 패턴을 탐지하고, agent-patterns.md 참조로 일괄 전환하는 것을 권장한다.

<!-- AGENT_COMPLETE -->
